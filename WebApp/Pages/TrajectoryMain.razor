@page "/Trajectory"
@inject ILogger<TrajectoryMain> logger
@inject ISnackbar Snackbar
@inject IDialogService DialogService
<MudUnitAndReferenceChoiceTag HttpHost=@APIUtils.HostNameUnitConversion
                              HttpBasePath=@APIUtils.HostBasePathUnitConversion
                              HttpController="UnitSystem/"
                              UnitSystemName="@DataUtils.UnitAndReferenceParameters.UnitSystemName"
                              UnitSystemNameChanged="@DataUtils.UpdateUnitSystemName">
    @if (trajectoryList == null)
    {
        <p><em>Loading...</em></p>
    }
    else
    {
        <div hidden="@isHiddenMainPanel">
            <MudDataGrid T="TrajectoryLight" MultiSelection="true" Items="@trajectoryList" SelectedItemsChanged="@SelectedItemsChanged"
                         EditMode="DataGridEditMode.Form"
                         Hover="true" RowClick="@RowClicked"
                         SortMode="SortMode.Multiple" QuickFilter="@_trajectoryFilter" Filterable="false"
                         ReadOnly="false" ColumnResizeMode="ResizeMode.Column" Elevation="0">
                <ToolBarContent>
                    <MudText Typo="Typo.h6">Trajectory</MudText>
                    <MudButton OnClick="@AddTrajectory" Color="@Color.Success" Class="add-item-btn">Add</MudButton>
                    <MudButton OnClick="@DeleteSelectedTrajectory" Color="@Color.Error" Class="add-item-btn">Delete</MudButton>
                    <MudSpacer />
                    <MudTextField @bind-Value="_searchString" Placeholder="Search" Adornment="Adornment.Start" Immediate="true"
                                  AdornmentIcon="@Icons.Material.Filled.Search" IconSize="Size.Medium" Class="mt-0"></MudTextField>
                </ToolBarContent>
                <Columns>
                    <SelectColumn T="TrajectoryLight" />
                    <PropertyColumn Property="x => x.Name" Title="Trajectory" CellStyle="width: 30%;" Sortable="true" Editable="false" />
                    <PropertyColumn Property="x => x.Description" Title="Description" CellStyle="width: 40%;" Sortable="true" Editable="false" />
                    <PropertyColumn Property="x => GetWellBoreNameFromID(x.WellBoreID)" Title="WellBore" Sortable="true" />
                    <TemplateColumn CellClass="d-flex justify-end">
                        <CellTemplate>
                            <MudIconButton Size="@Size.Small" Icon="@Icons.Material.Outlined.Delete" OnClick="(() => DeleteTrajectory(context.Item.MetaInfo.ID))" />
                        </CellTemplate>
                    </TemplateColumn>
                </Columns>
                <PagerContent>
                    <MudDataGridPager T="TrajectoryLight" />
                </PagerContent>
            </MudDataGrid>
        </div>
    }
    @if (isHiddenMainPanel && (!isHiddenEditPanel))
    {
        <TrajectoryEdit TrajectoryId="@trajectoryIdBeingEdited" WellBoreList="@wellBoreList" ValueChanged="HandleEditPanelClosed" />
    }
</MudUnitAndReferenceChoiceTag>

@code {
    // Trajectory-related variables
    private List<TrajectoryLight> trajectoryList = new();
    private List<TrajectoryLight> selectedTrajectoryList = new();
    private TrajectoryLight? currentTrajectory;
    private List<object?>? inputDataList = new(); // container used to pass input data to the TrajectoryEdit razor component without specifying content types (required by µservice Template)
                                                  // Other variables
    private List<WellBore>? wellBoreList;
    // UI related variables
    public bool isHiddenMainPanel;
    public bool isHiddenEditPanel;
    private Guid? trajectoryIdBeingEdited;
    private string? _searchString;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            // Show main panel
            isHiddenMainPanel = false;
            isHiddenEditPanel = true;
            currentTrajectory = null;

            // Starting all loading tasks asynchronously
            logger.LogInformation("Trying to load list of wellbores from client: " + APIUtils.HttpClientWellBore);
            var wellBoreTask = APIUtils.ClientWellBore.GetAllWellBoreAsync();
            logger.LogInformation("Trying to load list of trajectories from client: " + APIUtils.HostNameTrajectory);
            var trajectoryTask = APIUtils.ClientTrajectory.GetAllTrajectoryLightAsync();

            List<Task> loadingTaskList = [trajectoryTask, wellBoreTask];

            // Awaiting tasks and retrieve results as they become available
            while (loadingTaskList.Count > 0)
            {
                Task finishedTask = await Task.WhenAny(loadingTaskList);
                if (finishedTask == trajectoryTask)
                {
                    try
                    {
                        trajectoryList = (List<TrajectoryLight>)await trajectoryTask; // awaiting the finished task allows to retrieve its result and throw exception if needed
                        if (trajectoryList != null)
                        {
                            trajectoryList.Sort((t1, t2) => t1.Name.CompareTo(t2.Name));
                        }
                        else
                        {
                            logger.LogWarning("Returned list of Trajectory were null on initialization");
                            Snackbar.Add("Returned list of Trajectory were null on initialization", Severity.Warning);
                        }
                    }
                    catch (ApiException ex)
                    {
                        logger.LogError(ex, "Impossible to load Trajectory from client");
                    }
                }
                else if (finishedTask == wellBoreTask)
                {
                    try
                    {
                        wellBoreList = (List<WellBore>)await wellBoreTask; // awaiting the finished task allows to retrieve its result and throw exception if needed
                        if (wellBoreList != null)
                        {
                            wellBoreList.Sort((f1, f2) => f1.Name.CompareTo(f2.Name));
                        }
                        else
                        {
                            logger.LogWarning("Returned list of WellBore were null on initialization");
                            Snackbar.Add("Returned list of WellBore were null on initialization", Severity.Warning);
                        }
                    }
                    catch (ApiException ex)
                    {
                        logger.LogError(ex, "Impossible to load WellBore from client");
                    }
                }
                loadingTaskList.Remove(finishedTask);
            }
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Problem Trajectory initialization");
        }
        await InvokeAsync(() => { StateHasChanged(); });
    }

    private async Task AddTrajectory()
    {
        isHiddenMainPanel = true;
        isHiddenEditPanel = false;
        trajectoryIdBeingEdited = null;
    }

    private async Task EditTrajectory(Guid id)
    {
        isHiddenMainPanel = true;
        isHiddenEditPanel = false;
        trajectoryIdBeingEdited = id;
    }
    private async Task HandleEditPanelClosed()
    {
        isHiddenMainPanel = false;
        isHiddenEditPanel = true;
        trajectoryIdBeingEdited = null;
        await OnInitializedAsync();
    }

    private async Task<bool> ConfirmDeletion()
    {
        var options = new DialogOptions
            {
                CloseOnEscapeKey = true,
                MaxWidth = MaxWidth.Small,
                FullWidth = true
            };
        var dialog = await DialogService.ShowAsync<DialogDeleteTemplate>("DELETE", options);
        var result = await dialog.Result;
        StateHasChanged();
        if (result == null)
        {
            return false;
        }
        else
        {
            return (!result.Canceled);
        }
    }
    private async Task DeleteTrajectory(Guid id)
    {
        try
        {
            if (await ConfirmDeletion())
            {
                await APIUtils.ClientTrajectory.DeleteTrajectoryByIdAsync(id);
                await OnInitializedAsync();
            }
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Impossible to delete Trajectory");
        }
    }


    private async Task DeleteSelectedTrajectory()
    {
        try
        {
            if (await ConfirmDeletion())
            {
                foreach (TrajectoryLight trajectory in selectedTrajectoryList)
                {
                    await APIUtils.ClientTrajectory.DeleteTrajectoryByIdAsync(trajectory.MetaInfo.ID);
                }
                await OnInitializedAsync();
            }
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Impossible to delete all Trajectory");
        }

    }

    //Quick filter - filter gobally across multiple columns with the same input
    private Func<TrajectoryLight, bool>
    _trajectoryFilter => x =>
    {
        if (string.IsNullOrWhiteSpace(_searchString))
            return true;
        if ($"{x.Name} {x.Description}".Contains(_searchString))
            return true;

        return false;
    };

    //Events
    private void StartedEditingItem(TrajectoryLight item)
    {
        //Activating Edit event capture with parameter StartedEditingItem="@StartedEditingItem" in MudDataGrid; arguments are specified in OnClick="@context.Actions.StartedEditingItem(...)"
    }

    private void CancelledEditingItem(TrajectoryLight item)
    {
        //Activating Cancel event capture with parameter CancelledEditingItem = "@CancelledEditingItem" in MudDataGrid; arguments are specified in OnClick="@context.Actions.CancelledEditingItem(...)"
    }

    private void CommittedItemChanges(TrajectoryLight item)
    {
        //Activating Commit event capture with parameter CommittedItemChanges = "@CommittedItemChanges" in MudDataGrid; arguments are specified in OnClick="@context.Actions.CommittedEditingItem(...)"
    }

    void SelectedItemsChanged(HashSet<TrajectoryLight>
        items)
    {
        selectedTrajectoryList.Clear();
        selectedTrajectoryList.InsertRange(0, items);
    }

    private async Task RowClicked(DataGridRowClickEventArgs<TrajectoryLight> args)
    {
        await EditTrajectory(args.Item.MetaInfo.ID);
    }

    public string GetWellBoreNameFromID(Guid id)
    {
        if (id != Guid.Empty && wellBoreList != null && wellBoreList.Count > 0)
        {
            try
            {
                WellBore wb = wellBoreList.Find(x => x.MetaInfo.ID.Equals(id));
                if (wb != null && wb.MetaInfo != null)
                    return wb.Name;
            }
            catch (ArgumentNullException ex)
            {
                logger.LogWarning(ex, "Impossible to retrieve the WellBore of given ID");
            }
        }
        return "NA";
    }
}
