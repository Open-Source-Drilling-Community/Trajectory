@page "/Trajectory"
@using System.Text;
@using NORCE.Drilling.Trajectory.WebApp.Client
@using NORCE.Drilling.Trajectory.ModelClientShared;

<h1>Trajectory Editor</h1>

<p>This page is used to manage trajectories. The Field/Cluster/Slot/Well columns can be used to filter the available WellBores</p>
@if (trajectories == null)
{
	<p><em>Loading...</em></p>
}
else
{
	<h2>Trajectory List</h2>
	<table class="tableTrajectory">
		<thead>
			<tr>
				<th class="TrajectoryName">Name</th>
				<th class="TrajectoryDescription">Description</th>
				<th class="FieldName">Field Name (filter)</th>
				<th class="ClusterName">Cluster Name (filter)</th>
				<th class="SlotName">Slot Name (filter)</th>
				<th class="WellName">Well Name (filter)</th>
				<th class="WellBoreName">WellBore Name</th>
				<th class="RowButtons"></th>
			</tr>
		</thead>
		<tbody>
			@for (int i = 0; i < trajectories.Count; i++)
			{
				var local = i;
				<tr>
					<td>
						<span class="TrajectoryName" hidden="@IsTrajectoryDisplayHidden[i]">@trajectories[i].Name</span>
						<input class="text" type="text" hidden="@IsTrajectoryInputHidden[i]" @bind="@updatedTrajectory.Name" />
					</td>
					<td>
						<span class="TrajectoryDescription" hidden="@IsTrajectoryDisplayHidden[i]">@trajectories[i].Description</span>
						<input class="text" type="text" hidden="@IsTrajectoryInputHidden[i]" @bind="@updatedTrajectory.Description" />
					</td>
					<td>
						<span class="FieldName" hidden="@IsTrajectoryDisplayHidden[i]">@((wellBores.ContainsKey(trajectories[i].WellboreID) && wells.ContainsKey(wellBores[trajectories[i].WellboreID].WellID) && clusters.ContainsKey(wells[wellBores[trajectories[i].WellboreID].WellID].ClusterID)) ? clusters[wells[wellBores[trajectories[i].WellboreID].WellID].ClusterID]?.Field?.Name : null)</span>
						<select hidden="@IsTrajectoryInputHidden[i]" @bind="@editedFieldName">
							@foreach (Tuple<int, string, NORCE.Drilling.Field.ModelClientShared.Field> t in fields)
							{
								@if (!string.IsNullOrEmpty(editedFieldName) && editedFieldName.Equals(t.Item2))
								{
									<option selected>@t.Item2</option>
								}
								else
								{
									<option>@t.Item2</option>
								}
							}
						</select>
					</td>
					<td>
						<span class="ClusterName" hidden="@IsTrajectoryDisplayHidden[i]">@((wellBores.ContainsKey(trajectories[i].WellboreID) && wells.ContainsKey(wellBores[trajectories[i].WellboreID].WellID) && clusters.ContainsKey(wells[wellBores[trajectories[i].WellboreID].WellID].ClusterID)) ? clusters[wells[wellBores[trajectories[i].WellboreID].WellID].ClusterID]?.Name : null)</span>
						<select hidden="@IsTrajectoryInputHidden[i]" @bind="@editedClusterName">
							@foreach (KeyValuePair<int, NORCE.Drilling.Cluster.ModelClientShared.Cluster> pair in clusters)
							{
								@if (string.IsNullOrEmpty(editedFieldName) || (pair.Value != null && pair.Value.Field == null) || (pair.Value != null && pair.Value.Field != null && !string.IsNullOrEmpty(pair.Value.Field.Name) && pair.Value.Field.Name.Equals(editedFieldName)))
								{
									@if (!string.IsNullOrEmpty(editedClusterName) && editedClusterName.Equals(pair.Value.Name))
									{
										<option selected>@pair.Value.Name</option>
									}
									else
									{
										<option>@pair.Value.Name</option>
									}
								}
							}
						</select>
					</td>
					<td>
						<span class="SlotName" hidden="@IsTrajectoryDisplayHidden[i]">@((wellBores.ContainsKey(trajectories[i].WellboreID) && wells.ContainsKey(wellBores[trajectories[i].WellboreID].WellID) && clusters.ContainsKey(wells[wellBores[trajectories[i].WellboreID].WellID].ClusterID)) ? clusters[wells[wellBores[trajectories[i].WellboreID].WellID].ClusterID].GetSlot(wells[wellBores[trajectories[i].WellboreID].WellID].SlotID)?.Name : null)</span>
						<select hidden="@IsTrajectoryInputHidden[i]" @bind="@editedSlotName">
							<option></option>
							@foreach (int key in clusters.Keys)
							{
								@if (!string.IsNullOrEmpty(editedClusterName) && clusters[key] != null && clusters[key].Slots != null && !string.IsNullOrEmpty(clusters[key].Name) && clusters[key].Name.Equals(editedClusterName))
								{
									<optgroup label="@clusters[key].Name">
										@foreach (NORCE.Drilling.Cluster.ModelClientShared.Slot s in clusters[key].Slots)
										{
											@if (!string.IsNullOrEmpty(editedSlotName) && editedSlotName.Equals(s.Name))
											{
												<option selected>@s.Name</option>
											}
											else
											{
												<option>@s.Name</option>
											}
										}
									</optgroup>
								}
								else if (string.IsNullOrEmpty(editedClusterName) && clusters[key] != null && clusters[key].Slots != null)
								{
									@if (!string.IsNullOrEmpty(editedFieldName) && clusters[key].Field != null && clusters[key].Field.Name.Equals(editedFieldName))
									{
										<optgroup label=@clusters[key].Name>
											@foreach (NORCE.Drilling.Cluster.ModelClientShared.Slot s in clusters[key].Slots)
											{
												@if (!string.IsNullOrEmpty(editedSlotName) && editedSlotName.Equals(s.Name))
												{
													<option selected>@s.Name</option>
												}
												else
												{
													<option>@s.Name</option>
												}
											}
										</optgroup>
									}
									else if (string.IsNullOrEmpty(editedFieldName))
									{
										<optgroup label=@clusters[key].Name>
											@foreach (NORCE.Drilling.Cluster.ModelClientShared.Slot s in clusters[key].Slots)
											{
												@if (!string.IsNullOrEmpty(editedSlotName) && editedSlotName.Equals(s.Name))
												{
													<option selected>@s.Name</option>
												}
												else
												{
													<option>@s.Name</option>
												}
											}
										</optgroup>
									}
								}
							}
						</select>
					</td>
					<td>
						<span class="WellName" hidden="@IsTrajectoryDisplayHidden[i]">@(wellBores.ContainsKey(trajectories[i].WellboreID) && wells.ContainsKey(wellBores[trajectories[i].WellboreID].WellID) ? wells[wellBores[trajectories[i].WellboreID].WellID]?.Name : null)</span>
						<select hidden="@IsTrajectoryInputHidden[i]" @bind="@editedWellName">
							<option></option>
							@foreach (int key in clusters.Keys)
							{
								@if (!string.IsNullOrEmpty(editedClusterName) && clusters[key] != null && clusters[key].Slots != null && !string.IsNullOrEmpty(clusters[key].Name) && clusters[key].Name.Equals(editedClusterName))
								{
									@foreach (NORCE.Drilling.Cluster.ModelClientShared.Slot s in clusters[key].Slots)
									{
										@if (!string.IsNullOrEmpty(editedSlotName) && editedSlotName.Equals(s.Name))
										{
											<optgroup label=@(s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
												@foreach (int wKey in wells.Keys)
												{
													@if (s.ID.Equals(wells[wKey].SlotID))
													{
														@if (!string.IsNullOrEmpty(editedWellName) && wells[wKey] != null && !string.IsNullOrEmpty(wells[wKey].Name) && editedWellName.Equals(wells[wKey].Name))
														{
															<option selected>@wells[wKey].Name</option>
														}
														else
														{
															<option>@wells[wKey].Name</option>
														}
													}
												}
											</optgroup>
										}
										else if (string.IsNullOrEmpty(editedSlotName))
										{
											<optgroup label=@(s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
												@foreach (int wKey in wells.Keys)
												{
													@if (s.ID.Equals(wells[wKey].SlotID))
													{
														@if (!string.IsNullOrEmpty(editedWellName) && wells[wKey] != null && !string.IsNullOrEmpty(wells[wKey].Name) && editedWellName.Equals(wells[wKey].Name))
														{
															<option selected>@wells[wKey].Name</option>
														}
														else
														{
															<option>@wells[wKey].Name</option>
														}
													}
												}
											</optgroup>
										}
									}
								}
								else if (string.IsNullOrEmpty(editedClusterName) && clusters[key] != null && clusters[key].Slots != null)
								{
									@if (!string.IsNullOrEmpty(editedFieldName) && clusters[key].Field != null && clusters[key].Field.Name.Equals(editedFieldName))
									{
										@foreach (NORCE.Drilling.Cluster.ModelClientShared.Slot s in clusters[key].Slots)
										{
											@if (!string.IsNullOrEmpty(editedSlotName) && editedSlotName.Equals(s.Name))
											{
												<optgroup label=@(s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
													@foreach (int wKey in wells.Keys)
													{
														@if (s.ID.Equals(wells[wKey].SlotID))
														{
															@if (!string.IsNullOrEmpty(editedWellName) && wells[wKey] != null && !string.IsNullOrEmpty(wells[wKey].Name) && editedWellName.Equals(wells[wKey].Name))
															{
																<option selected>@wells[wKey].Name</option>
															}
															else
															{
																<option>@wells[wKey].Name</option>
															}
														}
													}
												</optgroup>
											}
											else if (string.IsNullOrEmpty(editedSlotName))
											{
												<optgroup label=@(s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
													@foreach (int wKey in wells.Keys)
													{
														@if (s.ID.Equals(wells[wKey].SlotID))
														{
															@if (!string.IsNullOrEmpty(editedWellName) && wells[wKey] != null && !string.IsNullOrEmpty(wells[wKey].Name) && editedWellName.Equals(wells[wKey].Name))
															{
																<option selected>@wells[wKey].Name</option>
															}
															else
															{
																<option>@wells[wKey].Name</option>
															}
														}
													}
												</optgroup>
											}
										}
									}
									else if (string.IsNullOrEmpty(editedFieldName))
									{
										@foreach (NORCE.Drilling.Cluster.ModelClientShared.Slot s in clusters[key].Slots)
										{
											@if (!string.IsNullOrEmpty(editedSlotName) && editedSlotName.Equals(s.Name))
											{
												<optgroup label=@(s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
													@foreach (int wKey in wells.Keys)
													{
														@if (s.ID.Equals(wells[wKey].SlotID))
														{
															@if (!string.IsNullOrEmpty(editedWellName) && wells[wKey] != null && !string.IsNullOrEmpty(wells[wKey].Name) && editedWellName.Equals(wells[wKey].Name))
															{
																<option selected>@wells[wKey].Name</option>
															}
															else
															{
																<option>@wells[wKey].Name</option>
															}
														}
													}
												</optgroup>
											}
											else if (string.IsNullOrEmpty(editedSlotName))
											{
												<optgroup label=@(s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
													@foreach (int wKey in wells.Keys)
													{
														@if (s.ID.Equals(wells[wKey].SlotID))
														{
															@if (!string.IsNullOrEmpty(editedWellName) && wells[wKey] != null && !string.IsNullOrEmpty(wells[wKey].Name) && editedWellName.Equals(wells[wKey].Name))
															{
																<option selected>@wells[wKey].Name</option>
															}
															else
															{
																<option>@wells[wKey].Name</option>
															}
														}
													}
												</optgroup>
											}
										}
									}
								}
							}
						</select>
					</td>
					<td>
						<span class="WellBoreName" hidden="@IsTrajectoryDisplayHidden[i]">@wellBores[trajectories[i].WellboreID]?.Name</span>
						<select hidden="@IsTrajectoryInputHidden[i]" @bind="@editedWellBoreName">
							<option></option>
							@foreach (int key in clusters.Keys)
							{
								@if (!string.IsNullOrEmpty(editedClusterName) && clusters[key] != null && clusters[key].Slots != null && !string.IsNullOrEmpty(clusters[key].Name) && clusters[key].Name.Equals(editedClusterName))
								{
									@foreach (NORCE.Drilling.Cluster.ModelClientShared.Slot s in clusters[key].Slots)
									{
										@if (!string.IsNullOrEmpty(editedSlotName) && editedSlotName.Equals(s.Name))
										{
											@foreach (int wKey in wells.Keys)
											{
												@if (s.ID.Equals(wells[wKey].SlotID))
												{
													@if (!string.IsNullOrEmpty(editedWellName) && wells[wKey] != null && !string.IsNullOrEmpty(wells[wKey].Name) && editedWellName.Equals(wells[wKey].Name))
													{
														<optgroup label=@(wells[wKey].Name + " @ " + s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
															@foreach (int wbKey in wellBores.Keys)
															{
																@if (wells[wKey].ID == wellBores[wbKey].WellID)
																{
																	@if (!string.IsNullOrEmpty(editedWellBoreName) && wellBores[wbKey] != null && !string.IsNullOrEmpty(wellBores[wbKey].Name) && editedWellBoreName.Equals(wellBores[wbKey].Name))
																	{
																		<option selected>@wellBores[wbKey].Name</option>
																	}
																	else if (string.IsNullOrEmpty(editedWellBoreName))
																	{
																		<option>@wellBores[wbKey].Name</option>
																	}
																}
															}
														</optgroup>

													}
													else if (string.IsNullOrEmpty(editedWellName))
													{
														<optgroup label=@(wells[wKey].Name + " @ " + s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
															@foreach (int wbKey in wellBores.Keys)
															{
																@if (wells[wKey].ID == wellBores[wbKey].WellID)
																{
																	@if (!string.IsNullOrEmpty(editedWellBoreName) && wellBores[wbKey] != null && !string.IsNullOrEmpty(wellBores[wbKey].Name) && editedWellBoreName.Equals(wellBores[wbKey].Name))
																	{
																		<option selected>@wellBores[wbKey].Name</option>
																	}
																	else if (string.IsNullOrEmpty(editedWellBoreName))
																	{
																		<option>@wellBores[wbKey].Name</option>
																	}
																}
															}
														</optgroup>
													}
												}
											}
										}
										else if (string.IsNullOrEmpty(editedSlotName))
										{
											@foreach (int wKey in wells.Keys)
											{
												@if (s.ID.Equals(wells[wKey].SlotID))
												{
													@if (!string.IsNullOrEmpty(editedWellName) && wells[wKey] != null && !string.IsNullOrEmpty(wells[wKey].Name) && editedWellName.Equals(wells[wKey].Name))
													{
														<optgroup label=@(wells[wKey].Name + " @ " + s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
															@foreach (int wbKey in wellBores.Keys)
															{
																@if (wells[wKey].ID == wellBores[wbKey].WellID)
																{
																	@if (!string.IsNullOrEmpty(editedWellBoreName) && wellBores[wbKey] != null && !string.IsNullOrEmpty(wellBores[wbKey].Name) && editedWellBoreName.Equals(wellBores[wbKey].Name))
																	{
																		<option selected>@wellBores[wbKey].Name</option>
																	}
																	else if (string.IsNullOrEmpty(editedWellBoreName))
																	{
																		<option>@wellBores[wbKey].Name</option>
																	}
																}
															}
														</optgroup>
													}
													else if (string.IsNullOrEmpty(editedWellName))
													{
														<optgroup label=@(wells[wKey].Name + " @ " + s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
															@foreach (int wbKey in wellBores.Keys)
															{
																@if (wells[wKey].ID == wellBores[wbKey].WellID)
																{
																	@if (!string.IsNullOrEmpty(editedWellBoreName) && wellBores[wbKey] != null && !string.IsNullOrEmpty(wellBores[wbKey].Name) && editedWellBoreName.Equals(wellBores[wbKey].Name))
																	{
																		<option selected>@wellBores[wbKey].Name</option>
																	}
																	else if (string.IsNullOrEmpty(editedWellBoreName))
																	{
																		<option>@wellBores[wbKey].Name</option>
																	}
																}
															}
														</optgroup>
													}
												}
											}
										}
									}
								}
								else if (string.IsNullOrEmpty(editedClusterName) && clusters[key] != null && clusters[key].Slots != null)
								{
									@if (!string.IsNullOrEmpty(editedFieldName) && clusters[key].Field != null && clusters[key].Field.Name.Equals(editedFieldName))
									{
										@foreach (NORCE.Drilling.Cluster.ModelClientShared.Slot s in clusters[key].Slots)
										{
											@if (!string.IsNullOrEmpty(editedSlotName) && editedSlotName.Equals(s.Name))
											{
												@foreach (int wKey in wells.Keys)
												{
													@if (s.ID.Equals(wells[wKey].SlotID))
													{
														@if (!string.IsNullOrEmpty(editedWellName) && wells[wKey] != null && !string.IsNullOrEmpty(wells[wKey].Name) && editedWellName.Equals(wells[wKey].Name))
														{
															<optgroup label=@(wells[wKey].Name + " @ " + s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
																@foreach (int wbKey in wellBores.Keys)
																{
																	@if (wells[wKey].ID == wellBores[wbKey].WellID)
																	{
																		@if (!string.IsNullOrEmpty(editedWellBoreName) && wellBores[wbKey] != null && !string.IsNullOrEmpty(wellBores[wbKey].Name) && editedWellBoreName.Equals(wellBores[wbKey].Name))
																		{
																			<option selected>@wellBores[wbKey].Name</option>
																		}
																		else if (string.IsNullOrEmpty(editedWellBoreName))
																		{
																			<option>@wellBores[wbKey].Name</option>
																		}
																	}
																}
															</optgroup>
														}
														else if (string.IsNullOrEmpty(editedWellName))
														{
															<optgroup label=@(wells[wKey].Name + " @ " + s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
																@foreach (int wbKey in wellBores.Keys)
																{
																	@if (wells[wKey].ID == wellBores[wbKey].WellID)
																	{
																		@if (!string.IsNullOrEmpty(editedWellBoreName) && wellBores[wbKey] != null && !string.IsNullOrEmpty(wellBores[wbKey].Name) && editedWellBoreName.Equals(wellBores[wbKey].Name))
																		{
																			<option selected>@wellBores[wbKey].Name</option>
																		}
																		else if (string.IsNullOrEmpty(editedWellBoreName))
																		{
																			<option>@wellBores[wbKey].Name</option>
																		}
																	}
																}
															</optgroup>
														}
													}
												}
											}
											else if (string.IsNullOrEmpty(editedSlotName))
											{
												@foreach (int wKey in wells.Keys)
												{
													@if (s.ID.Equals(wells[wKey].SlotID))
													{
														@if (!string.IsNullOrEmpty(editedWellName) && wells[wKey] != null && !string.IsNullOrEmpty(wells[wKey].Name) && editedWellName.Equals(wells[wKey].Name))
														{
															<optgroup label=@(wells[wKey].Name + " @ " + s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
																@foreach (int wbKey in wellBores.Keys)
																{
																	@if (wells[wKey].ID == wellBores[wbKey].WellID)
																	{
																		@if (!string.IsNullOrEmpty(editedWellBoreName) && wellBores[wbKey] != null && !string.IsNullOrEmpty(wellBores[wbKey].Name) && editedWellBoreName.Equals(wellBores[wbKey].Name))
																		{
																			<option selected>@wellBores[wbKey].Name</option>
																		}
																		else if (string.IsNullOrEmpty(editedWellBoreName))
																		{
																			<option>@wellBores[wbKey].Name</option>
																		}
																	}
																}
															</optgroup>
														}
														else if (string.IsNullOrEmpty(editedWellName))
														{
															<optgroup label=@(wells[wKey].Name + " @ " + s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
																@foreach (int wbKey in wellBores.Keys)
																{
																	@if (wells[wKey].ID == wellBores[wbKey].WellID)
																	{
																		@if (!string.IsNullOrEmpty(editedWellBoreName) && wellBores[wbKey] != null && !string.IsNullOrEmpty(wellBores[wbKey].Name) && editedWellBoreName.Equals(wellBores[wbKey].Name))
																		{
																			<option selected>@wellBores[wbKey].Name</option>
																		}
																		else if (string.IsNullOrEmpty(editedWellBoreName))
																		{
																			<option>@wellBores[wbKey].Name</option>
																		}
																	}
																}
															</optgroup>
														}
													}
												}
											}
										}
									}
									else if (string.IsNullOrEmpty(editedFieldName))
									{
										@foreach (NORCE.Drilling.Cluster.ModelClientShared.Slot s in clusters[key].Slots)
										{
											@if (!string.IsNullOrEmpty(editedSlotName) && editedSlotName.Equals(s.Name))
											{
												@foreach (int wKey in wells.Keys)
												{
													@if (s.ID.Equals(wells[wKey].SlotID))
													{
														@if (!string.IsNullOrEmpty(editedWellName) && wells[wKey] != null && !string.IsNullOrEmpty(wells[wKey].Name) && editedWellName.Equals(wells[wKey].Name))
														{
															<optgroup label=@(wells[wKey].Name + " @ " + s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
																@foreach (int wbKey in wellBores.Keys)
																{
																	@if (wells[wKey].ID == wellBores[wbKey].WellID)
																	{
																		@if (!string.IsNullOrEmpty(editedWellBoreName) && wellBores[wbKey] != null && !string.IsNullOrEmpty(wellBores[wbKey].Name) && editedWellBoreName.Equals(wellBores[wbKey].Name))
																		{
																			<option selected>@wellBores[wbKey].Name</option>
																		}
																		else if (string.IsNullOrEmpty(editedWellBoreName))
																		{
																			<option>@wellBores[wbKey].Name</option>
																		}
																	}
																}
															</optgroup>
														}
														else if (string.IsNullOrEmpty(editedWellName))
														{
															<optgroup label=@(wells[wKey].Name + " @ " + s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
																@foreach (int wbKey in wellBores.Keys)
																{
																	@if (wells[wKey].ID == wellBores[wbKey].WellID)
																	{
																		@if (!string.IsNullOrEmpty(editedWellBoreName) && wellBores[wbKey] != null && !string.IsNullOrEmpty(wellBores[wbKey].Name) && editedWellBoreName.Equals(wellBores[wbKey].Name))
																		{
																			<option selected>@wellBores[wbKey].Name</option>
																		}
																		else if (string.IsNullOrEmpty(editedWellBoreName))
																		{
																			<option>@wellBores[wbKey].Name</option>
																		}
																	}
																}
															</optgroup>
														}
													}
												}
											}
											else if (string.IsNullOrEmpty(editedSlotName))
											{
												@foreach (int wKey in wells.Keys)
												{
													@if (s.ID.Equals(wells[wKey].SlotID))
													{
														@if (!string.IsNullOrEmpty(editedWellName) && wells[wKey] != null && !string.IsNullOrEmpty(wells[wKey].Name) && editedWellName.Equals(wells[wKey].Name))
														{
															<optgroup label=@(wells[wKey].Name + " @ " + s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
																@foreach (int wbKey in wellBores.Keys)
																{
																	@if (wells[wKey].ID == wellBores[wbKey].WellID)
																	{
																		@if (!string.IsNullOrEmpty(editedWellBoreName) && wellBores[wbKey] != null && !string.IsNullOrEmpty(wellBores[wbKey].Name) && editedWellBoreName.Equals(wellBores[wbKey].Name))
																		{
																			<option selected>@wellBores[wbKey].Name</option>
																		}
																		else if (string.IsNullOrEmpty(editedWellBoreName))
																		{
																			<option>@wellBores[wbKey].Name</option>
																		}
																	}
																}
															</optgroup>
														}
														else if (string.IsNullOrEmpty(editedWellName))
														{
															<optgroup label=@(wells[wKey].Name + " @ " + s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
																@foreach (int wbKey in wellBores.Keys)
																{
																	@if (wells[wKey].ID == wellBores[wbKey].WellID)
																	{
																		@if (!string.IsNullOrEmpty(editedWellBoreName) && wellBores[wbKey] != null && !string.IsNullOrEmpty(wellBores[wbKey].Name) && editedWellBoreName.Equals(wellBores[wbKey].Name))
																		{
																			<option selected>@wellBores[wbKey].Name</option>
																		}
																		else if (string.IsNullOrEmpty(editedWellBoreName))
																		{
																			<option>@wellBores[wbKey].Name</option>
																		}
																	}
																}
															</optgroup>
														}
													}
												}
											}
										}
									}
								}
							}
						</select>
					</td>
					<td>
						<button class="btn btn-primary" hidden="@IsTrajectoryEditButtonHidden[i]" @onclick="@(() => Edit(local))">Edit</button>
						<button class="btn btn-primary" hidden="@IsTrajectoryDeleteButtonHidden[i]" @onclick="@(() => Delete(local))">Delete</button>
						<button class="btn btn-primary" hidden="@IsTrajectoryEditButtonHidden[i]" @onclick="@(() => Copy(local))">Copy</button>
						<button class="btn btn-primary" hidden="@IsTrajectoryUpdateButtonHidden[i]" @onclick="@(() => Update(local))">Update</button>
						<button class="btn btn-primary" hidden="@IsTrajectoryCancelButtonHidden[i]" @onclick="@(() => Cancel(local))">Cancel</button>
					</td>
				</tr>
			}
		</tbody>
		<tfoot>
			<tr>
				<td>
					<input class="text" type="text" hidden="@IsTrajectoryAddInput" @bind="@editedTrajectory.Name" />
				</td>
				<td>
					<input class="text" type="text" hidden="@IsTrajectoryAddInput" @bind="@editedTrajectory.Description" />
				</td>
				<td>
					<select hidden="@IsTrajectoryAddInput" @bind="@editedFieldName">
						@if (fields != null)
						{
							@foreach (Tuple<int, string, NORCE.Drilling.Field.ModelClientShared.Field> t in fields)
							{
								<option>@t.Item2</option>
							}
						}
					</select>
				</td>
				<td>
					<select hidden="@IsTrajectoryAddInput" @bind="@editedClusterName">
						@foreach (KeyValuePair<int, NORCE.Drilling.Cluster.ModelClientShared.Cluster> pair in clusters)
						{
							@if (string.IsNullOrEmpty(editedFieldName) || (pair.Value != null && pair.Value.Field == null) || (pair.Value != null && pair.Value.Field != null && !string.IsNullOrEmpty(pair.Value.Field.Name) && pair.Value.Field.Name.Equals(editedFieldName)))
							{
								@if (!string.IsNullOrEmpty(editedClusterName) && editedClusterName.Equals(pair.Value.Name))
								{
									<option selected>@pair.Value.Name</option>
								}
								else
								{
									<option>@pair.Value.Name</option>
								}
							}
						}
					</select>
				</td>
				<td>
					<select hidden="@IsTrajectoryAddInput" @bind="@editedSlotName">
						<option></option>
						@foreach (int key in clusters.Keys)
						{
							@if (!string.IsNullOrEmpty(editedClusterName) && clusters[key] != null && clusters[key].Slots != null && !string.IsNullOrEmpty(clusters[key].Name) && clusters[key].Name.Equals(editedClusterName))
							{
								<optgroup label=@clusters[key].Name>
									@foreach (NORCE.Drilling.Cluster.ModelClientShared.Slot s in clusters[key].Slots)
									{
										@if (!string.IsNullOrEmpty(editedSlotName) && editedSlotName.Equals(s.Name))
										{
											<option selected>@s.Name</option>
										}
										else
										{
											<option>@s.Name</option>
										}
									}
								</optgroup>
							}
							else if (string.IsNullOrEmpty(editedClusterName) && clusters[key] != null && clusters[key].Slots != null)
							{
								@if (!string.IsNullOrEmpty(editedFieldName) && clusters[key].Field != null && clusters[key].Field.Name.Equals(editedFieldName))
								{
									<optgroup label=@clusters[key].Name>
										@foreach (NORCE.Drilling.Cluster.ModelClientShared.Slot s in clusters[key].Slots)
										{
											@if (!string.IsNullOrEmpty(editedSlotName) && editedSlotName.Equals(s.Name))
											{
												<option selected>@s.Name</option>
											}
											else
											{
												<option>@s.Name</option>
											}
										}
									</optgroup>
								}
								else if (string.IsNullOrEmpty(editedFieldName))
								{
									<optgroup label=@clusters[key].Name>
										@foreach (NORCE.Drilling.Cluster.ModelClientShared.Slot s in clusters[key].Slots)
										{
											@if (!string.IsNullOrEmpty(editedSlotName) && editedSlotName.Equals(s.Name))
											{
												<option selected>@s.Name</option>
											}
											else
											{
												<option>@s.Name</option>
											}
										}
									</optgroup>
								}
							}
						}
					</select>
				</td>
				<td>
					<select hidden="@IsTrajectoryAddInput" @bind="@editedWellName">
						<option></option>
						@foreach (int key in clusters.Keys)
						{
							@if (!string.IsNullOrEmpty(editedClusterName) && clusters[key] != null && clusters[key].Slots != null && !string.IsNullOrEmpty(clusters[key].Name) && clusters[key].Name.Equals(editedClusterName))
							{
								@foreach (NORCE.Drilling.Cluster.ModelClientShared.Slot s in clusters[key].Slots)
								{
									@if (!string.IsNullOrEmpty(editedSlotName) && editedSlotName.Equals(s.Name))
									{
										<optgroup label=@(s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
											@foreach (int wKey in wells.Keys)
											{
												@if (s.ID.Equals(wells[wKey].SlotID))
												{
													@if (!string.IsNullOrEmpty(editedWellName) && wells[wKey] != null && !string.IsNullOrEmpty(wells[wKey].Name) && editedWellName.Equals(wells[wKey].Name))
													{
														<option selected>@wells[wKey].Name</option>
													}
													else
													{
														<option>@wells[wKey].Name</option>
													}
												}
											}
										</optgroup>
									}
									else if (string.IsNullOrEmpty(editedSlotName))
									{
										<optgroup label=@(s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
											@foreach (int wKey in wells.Keys)
											{
												@if (s.ID.Equals(wells[wKey].SlotID))
												{
													@if (!string.IsNullOrEmpty(editedWellName) && wells[wKey] != null && !string.IsNullOrEmpty(wells[wKey].Name) && editedWellName.Equals(wells[wKey].Name))
													{
														<option selected>@wells[wKey].Name</option>
													}
													else
													{
														<option>@wells[wKey].Name</option>
													}
												}
											}
										</optgroup>
									}
								}
							}
							else if (string.IsNullOrEmpty(editedClusterName) && clusters[key] != null && clusters[key].Slots != null)
							{
								@if (!string.IsNullOrEmpty(editedFieldName) && clusters[key].Field != null && clusters[key].Field.Name.Equals(editedFieldName))
								{
									@foreach (NORCE.Drilling.Cluster.ModelClientShared.Slot s in clusters[key].Slots)
									{
										@if (!string.IsNullOrEmpty(editedSlotName) && editedSlotName.Equals(s.Name))
										{
											<optgroup label=@(s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
												@foreach (int wKey in wells.Keys)
												{
													@if (s.ID.Equals(wells[wKey].SlotID))
													{
														@if (!string.IsNullOrEmpty(editedWellName) && wells[wKey] != null && !string.IsNullOrEmpty(wells[wKey].Name) && editedWellName.Equals(wells[wKey].Name))
														{
															<option selected>@wells[wKey].Name</option>
														}
														else
														{
															<option>@wells[wKey].Name</option>
														}
													}
												}
											</optgroup>
										}
										else if (string.IsNullOrEmpty(editedSlotName))
										{
											<optgroup label=@(s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
												@foreach (int wKey in wells.Keys)
												{
													@if (s.ID.Equals(wells[wKey].SlotID))
													{
														@if (!string.IsNullOrEmpty(editedWellName) && wells[wKey] != null && !string.IsNullOrEmpty(wells[wKey].Name) && editedWellName.Equals(wells[wKey].Name))
														{
															<option selected>@wells[wKey].Name</option>
														}
														else
														{
															<option>@wells[wKey].Name</option>
														}
													}
												}
											</optgroup>
										}
									}
								}
								else if (string.IsNullOrEmpty(editedFieldName))
								{
									@foreach (NORCE.Drilling.Cluster.ModelClientShared.Slot s in clusters[key].Slots)
									{
										@if (!string.IsNullOrEmpty(editedSlotName) && editedSlotName.Equals(s.Name))
										{
											<optgroup label=@(s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
												@foreach (int wKey in wells.Keys)
												{
													@if (s.ID.Equals(wells[wKey].SlotID))
													{
														@if (!string.IsNullOrEmpty(editedWellName) && wells[wKey] != null && !string.IsNullOrEmpty(wells[wKey].Name) && editedWellName.Equals(wells[wKey].Name))
														{
															<option selected>@wells[wKey].Name</option>
														}
														else
														{
															<option>@wells[wKey].Name</option>
														}
													}
												}
											</optgroup>
										}
										else if (string.IsNullOrEmpty(editedSlotName))
										{
											<optgroup label=@(s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
												@foreach (int wKey in wells.Keys)
												{
													@if (s.ID.Equals(wells[wKey].SlotID))
													{
														@if (!string.IsNullOrEmpty(editedWellName) && wells[wKey] != null && !string.IsNullOrEmpty(wells[wKey].Name) && editedWellName.Equals(wells[wKey].Name))
														{
															<option selected>@wells[wKey].Name</option>
														}
														else
														{
															<option>@wells[wKey].Name</option>
														}
													}
												}
											</optgroup>
										}
									}
								}
							}
						}
					</select>
				</td>
				<td>
					<select hidden="@IsTrajectoryAddInput" @bind="@editedWellBoreName">
						<option></option>
						@foreach (int key in clusters.Keys)
						{
							@if (!string.IsNullOrEmpty(editedClusterName) && clusters[key] != null && clusters[key].Slots != null && !string.IsNullOrEmpty(clusters[key].Name) && clusters[key].Name.Equals(editedClusterName))
							{
								@foreach (NORCE.Drilling.Cluster.ModelClientShared.Slot s in clusters[key].Slots)
								{
									@if (!string.IsNullOrEmpty(editedSlotName) && editedSlotName.Equals(s.Name))
									{
										@foreach (int wKey in wells.Keys)
										{
											@if (s.ID.Equals(wells[wKey].SlotID))
											{
												@if (!string.IsNullOrEmpty(editedWellName) && wells[wKey] != null && !string.IsNullOrEmpty(wells[wKey].Name) && editedWellName.Equals(wells[wKey].Name))
												{
													<optgroup label=@(wells[wKey].Name + " @ " + s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
														@foreach (int wbKey in wellBores.Keys)
														{
															@if (wells[wKey].ID == wellBores[wbKey].WellID)
															{
																@if (!string.IsNullOrEmpty(editedWellBoreName) && wellBores[wbKey] != null && !string.IsNullOrEmpty(wellBores[wbKey].Name) && editedWellBoreName.Equals(wellBores[wbKey].Name))
																{
																	<option selected>@wellBores[wbKey].Name</option>
																}
																else if (string.IsNullOrEmpty(editedWellBoreName))
																{
																	<option>@wellBores[wbKey].Name</option>
																}
															}
														}
													</optgroup>

												}
												else if (string.IsNullOrEmpty(editedWellName))
												{
													<optgroup label=@(wells[wKey].Name + " @ " + s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
														@foreach (int wbKey in wellBores.Keys)
														{
															@if (wells[wKey].ID == wellBores[wbKey].WellID)
															{
																@if (!string.IsNullOrEmpty(editedWellBoreName) && wellBores[wbKey] != null && !string.IsNullOrEmpty(wellBores[wbKey].Name) && editedWellBoreName.Equals(wellBores[wbKey].Name))
																{
																	<option selected>@wellBores[wbKey].Name</option>
																}
																else if (string.IsNullOrEmpty(editedWellBoreName))
																{
																	<option>@wellBores[wbKey].Name</option>
																}
															}
														}
													</optgroup>
												}
											}
										}
									}
									else if (string.IsNullOrEmpty(editedSlotName))
									{
										@foreach (int wKey in wells.Keys)
										{
											@if (s.ID.Equals(wells[wKey].SlotID))
											{
												@if (!string.IsNullOrEmpty(editedWellName) && wells[wKey] != null && !string.IsNullOrEmpty(wells[wKey].Name) && editedWellName.Equals(wells[wKey].Name))
												{
													<optgroup label=@(wells[wKey].Name + " @ " + s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
														@foreach (int wbKey in wellBores.Keys)
														{
															@if (wells[wKey].ID == wellBores[wbKey].WellID)
															{
																@if (!string.IsNullOrEmpty(editedWellBoreName) && wellBores[wbKey] != null && !string.IsNullOrEmpty(wellBores[wbKey].Name) && editedWellBoreName.Equals(wellBores[wbKey].Name))
																{
																	<option selected>@wellBores[wbKey].Name</option>
																}
																else if (string.IsNullOrEmpty(editedWellBoreName))
																{
																	<option>@wellBores[wbKey].Name</option>
																}
															}
														}
													</optgroup>
												}
												else if (string.IsNullOrEmpty(editedWellName))
												{
													<optgroup label=@(wells[wKey].Name + " @ " + s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
														@foreach (int wbKey in wellBores.Keys)
														{
															@if (wells[wKey].ID == wellBores[wbKey].WellID)
															{
																@if (!string.IsNullOrEmpty(editedWellBoreName) && wellBores[wbKey] != null && !string.IsNullOrEmpty(wellBores[wbKey].Name) && editedWellBoreName.Equals(wellBores[wbKey].Name))
																{
																	<option selected>@wellBores[wbKey].Name</option>
																}
																else if (string.IsNullOrEmpty(editedWellBoreName))
																{
																	<option>@wellBores[wbKey].Name</option>
																}
															}
														}
													</optgroup>
												}
											}
										}
									}
								}
							}
							else if (string.IsNullOrEmpty(editedClusterName) && clusters[key] != null && clusters[key].Slots != null)
							{
								@if (!string.IsNullOrEmpty(editedFieldName) && clusters[key].Field != null && clusters[key].Field.Name.Equals(editedFieldName))
								{
									@foreach (NORCE.Drilling.Cluster.ModelClientShared.Slot s in clusters[key].Slots)
									{
										@if (!string.IsNullOrEmpty(editedSlotName) && editedSlotName.Equals(s.Name))
										{
											@foreach (int wKey in wells.Keys)
											{
												@if (s.ID.Equals(wells[wKey].SlotID))
												{
													@if (!string.IsNullOrEmpty(editedWellName) && wells[wKey] != null && !string.IsNullOrEmpty(wells[wKey].Name) && editedWellName.Equals(wells[wKey].Name))
													{
														<optgroup label=@(wells[wKey].Name + " @ " + s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
															@foreach (int wbKey in wellBores.Keys)
															{
																@if (wells[wKey].ID == wellBores[wbKey].WellID)
																{
																	@if (!string.IsNullOrEmpty(editedWellBoreName) && wellBores[wbKey] != null && !string.IsNullOrEmpty(wellBores[wbKey].Name) && editedWellBoreName.Equals(wellBores[wbKey].Name))
																	{
																		<option selected>@wellBores[wbKey].Name</option>
																	}
																	else if (string.IsNullOrEmpty(editedWellBoreName))
																	{
																		<option>@wellBores[wbKey].Name</option>
																	}
																}
															}
														</optgroup>
													}
													else if (string.IsNullOrEmpty(editedWellName))
													{
														<optgroup label=@(wells[wKey].Name + " @ " + s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
															@foreach (int wbKey in wellBores.Keys)
															{
																@if (wells[wKey].ID == wellBores[wbKey].WellID)
																{
																	@if (!string.IsNullOrEmpty(editedWellBoreName) && wellBores[wbKey] != null && !string.IsNullOrEmpty(wellBores[wbKey].Name) && editedWellBoreName.Equals(wellBores[wbKey].Name))
																	{
																		<option selected>@wellBores[wbKey].Name</option>
																	}
																	else if (string.IsNullOrEmpty(editedWellBoreName))
																	{
																		<option>@wellBores[wbKey].Name</option>
																	}
																}
															}
														</optgroup>
													}
												}
											}
										}
										else if (string.IsNullOrEmpty(editedSlotName))
										{
											@foreach (int wKey in wells.Keys)
											{
												@if (s.ID.Equals(wells[wKey].SlotID))
												{
													@if (!string.IsNullOrEmpty(editedWellName) && wells[wKey] != null && !string.IsNullOrEmpty(wells[wKey].Name) && editedWellName.Equals(wells[wKey].Name))
													{
														<optgroup label=@(wells[wKey].Name + " @ " + s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
															@foreach (int wbKey in wellBores.Keys)
															{
																@if (wells[wKey].ID == wellBores[wbKey].WellID)
																{
																	@if (!string.IsNullOrEmpty(editedWellBoreName) && wellBores[wbKey] != null && !string.IsNullOrEmpty(wellBores[wbKey].Name) && editedWellBoreName.Equals(wellBores[wbKey].Name))
																	{
																		<option selected>@wellBores[wbKey].Name</option>
																	}
																	else if (string.IsNullOrEmpty(editedWellBoreName))
																	{
																		<option>@wellBores[wbKey].Name</option>
																	}
																}
															}
														</optgroup>
													}
													else if (string.IsNullOrEmpty(editedWellName))
													{
														<optgroup label=@(wells[wKey].Name + " @ " + s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
															@foreach (int wbKey in wellBores.Keys)
															{
																@if (wells[wKey].ID == wellBores[wbKey].WellID)
																{
																	@if (!string.IsNullOrEmpty(editedWellBoreName) && wellBores[wbKey] != null && !string.IsNullOrEmpty(wellBores[wbKey].Name) && editedWellBoreName.Equals(wellBores[wbKey].Name))
																	{
																		<option selected>@wellBores[wbKey].Name</option>
																	}
																	else if (string.IsNullOrEmpty(editedWellBoreName))
																	{
																		<option>@wellBores[wbKey].Name</option>
																	}
																}
															}
														</optgroup>
													}
												}
											}
										}
									}
								}
								else if (string.IsNullOrEmpty(editedFieldName))
								{
									@foreach (NORCE.Drilling.Cluster.ModelClientShared.Slot s in clusters[key].Slots)
									{
										@if (!string.IsNullOrEmpty(editedSlotName) && editedSlotName.Equals(s.Name))
										{
											@foreach (int wKey in wells.Keys)
											{
												@if (s.ID.Equals(wells[wKey].SlotID))
												{
													@if (!string.IsNullOrEmpty(editedWellName) && wells[wKey] != null && !string.IsNullOrEmpty(wells[wKey].Name) && editedWellName.Equals(wells[wKey].Name))
													{
														<optgroup label=@(wells[wKey].Name + " @ " + s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
															@foreach (int wbKey in wellBores.Keys)
															{
																@if (wells[wKey].ID == wellBores[wbKey].WellID)
																{
																	@if (!string.IsNullOrEmpty(editedWellBoreName) && wellBores[wbKey] != null && !string.IsNullOrEmpty(wellBores[wbKey].Name) && editedWellBoreName.Equals(wellBores[wbKey].Name))
																	{
																		<option selected>@wellBores[wbKey].Name</option>
																	}
																	else if (string.IsNullOrEmpty(editedWellBoreName))
																	{
																		<option>@wellBores[wbKey].Name</option>
																	}
																}
															}
														</optgroup>
													}
													else if (string.IsNullOrEmpty(editedWellName))
													{
														<optgroup label=@(wells[wKey].Name + " @ " + s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
															@foreach (int wbKey in wellBores.Keys)
															{
																@if (wells[wKey].ID == wellBores[wbKey].WellID)
																{
																	@if (!string.IsNullOrEmpty(editedWellBoreName) && wellBores[wbKey] != null && !string.IsNullOrEmpty(wellBores[wbKey].Name) && editedWellBoreName.Equals(wellBores[wbKey].Name))
																	{
																		<option selected>@wellBores[wbKey].Name</option>
																	}
																	else if (string.IsNullOrEmpty(editedWellBoreName))
																	{
																		<option>@wellBores[wbKey].Name</option>
																	}
																}
															}
														</optgroup>
													}
												}
											}
										}
										else if (string.IsNullOrEmpty(editedSlotName))
										{
											@foreach (int wKey in wells.Keys)
											{
												@if (s.ID.Equals(wells[wKey].SlotID))
												{
													@if (!string.IsNullOrEmpty(editedWellName) && wells[wKey] != null && !string.IsNullOrEmpty(wells[wKey].Name) && editedWellName.Equals(wells[wKey].Name))
													{
														<optgroup label=@(wells[wKey].Name + " @ " + s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
															@foreach (int wbKey in wellBores.Keys)
															{
																@if (wells[wKey].ID == wellBores[wbKey].WellID)
																{
																	@if (!string.IsNullOrEmpty(editedWellBoreName) && wellBores[wbKey] != null && !string.IsNullOrEmpty(wellBores[wbKey].Name) && editedWellBoreName.Equals(wellBores[wbKey].Name))
																	{
																		<option selected>@wellBores[wbKey].Name</option>
																	}
																	else if (string.IsNullOrEmpty(editedWellBoreName))
																	{
																		<option>@wellBores[wbKey].Name</option>
																	}
																}
															}
														</optgroup>
													}
													else if (string.IsNullOrEmpty(editedWellName))
													{
														<optgroup label=@(wells[wKey].Name + " @ " + s.Name + " @ " + clusters[key].Name + " @ " +  clusters[key].Field.Name)>
															@foreach (int wbKey in wellBores.Keys)
															{
																@if (wells[wKey].ID == wellBores[wbKey].WellID)
																{
																	@if (!string.IsNullOrEmpty(editedWellBoreName) && wellBores[wbKey] != null && !string.IsNullOrEmpty(wellBores[wbKey].Name) && editedWellBoreName.Equals(wellBores[wbKey].Name))
																	{
																		<option selected>@wellBores[wbKey].Name</option>
																	}
																	else if (string.IsNullOrEmpty(editedWellBoreName))
																	{
																		<option>@wellBores[wbKey].Name</option>
																	}
																}
															}
														</optgroup>
													}
												}
											}
										}
									}
								}
							}
						}
					</select>
				</td>
				<td>
					<button class="btn btn-primary" hidden="@IsTrajectoryAddInput" @onclick="Add">Add</button>
					<button class="btn btn-primary" hidden="@IsTrajectoryAddInput" @onclick="Cancel">Cancel</button>
				</td>
			</tr>
		</tfoot>
	</table>

	<h4 hidden="@IsTableSurveyListHidden">Survey Program Selector for @trajectoryName</h4>


	@if (surveyProgram != null && surveyProgram.SurveyRunsList != null)
	{
		<table>
			<button class="btn btn-primary" hidden="@IsTableSurveyListHidden" @onclick="ToggleCheckbox ">Populate SurveyList</button>
		</table>
		<br />
		<table class="tableSurveyProgram" hidden="@IsTableSurveyListHidden">
			<thead>
				<tr>
					<th class="MD">FromDepth</th>
					<th class="MD">ToDepth</th>
					<th class="SurveyInstrument">Survey Instrument</th>
					<th class="SurveyProgramCheckBox">Active</th>
				</tr>
			</thead>
			<tbody>
				@if (surveyProgram != null && surveyProgram.SurveyRunsList != null)
				{
					int counter = 0;
					@foreach (NORCE.Drilling.SurveyProgram.ModelClientShared.SurveyRun run in surveyProgram.SurveyRunsList)
					{
						var lo = counter;
						<tr>
							<td>
								<span class="label">@run.StartMD</span>
							</td>
							<td>
								<span class="label">@run.FinalMD</span>
							</td>
							<td>
								<span class="label">@run.SurveyInstrument.Name</span>
							</td>
							<td>
								<input type="checkbox" @bind="@surveyProgramBoolvalues[lo]" />
							</td>
						</tr>
						counter++;
					}
				}
			</tbody>
		</table>
	}
	else
	{
		<h5 hidden="@IsTableSurveyListHidden">No Survey Program for  @trajectoryName in the database</h5>
	}
	<h3 hidden="@IsTableSurveyListHidden">Survey List Editor for @trajectoryName</h3>
	<table class="tableSurveyList" hidden="@IsTableSurveyListHidden">
		<thead>
			<tr>
				<th class="MD">MD</th>
				<th class="Inclination">Inclination</th>
				<th class="Azimuth">Azimuth</th>
				<th class="SurveyInstrument">Survey Instrument</th>
				<th class="SurveyListRowButtons"></th>
			</tr>
		</thead>
		<tbody>
			@for (int i = 0; i < surveyStations.Count; i++)
			{
				var local = i;
				<tr>
					<td>
						<span class="label" hidden="@IsSurveyStationDisplayHidden[i]">@surveyStations[i].MdWGS84</span>
						<input class="text" type="text" hidden="@IsSurveyStationInputHidden[i]" @bind="@updatedSurveyStation.MdWGS84" />
					</td>
					<td>
						<span class="label" hidden="@IsSurveyStationDisplayHidden[i]">@surveyStations[i].Incl</span>
						<input class="text" type="text" hidden="@IsSurveyStationInputHidden[i]" @bind="@updatedSurveyStation.Incl" />
					</td>
					<td>
						<span class="label" hidden="@IsSurveyStationDisplayHidden[i]">@surveyStations[i].AzWGS84</span>
						<input class="text" type="text" hidden="@IsSurveyStationInputHidden[i]" @bind="@updatedSurveyStation.AzWGS84" />
					</td>
					<td>
						<span class="label" hidden="@IsSurveyStationDisplayHidden[i]">@surveyStations[i].SurveyTool.Name</span>
						<select class="form-control selectpicker" hidden="@IsSurveyStationInputHidden[i]" @bind="@updatedSurveyStation.SurveyTool.Name">
							@*@if (surveyInstrumentNames != null)
								{
									@foreach (string surveyInstrumentName in surveyInstrumentNames)
									{
										<option>@surveyInstrumentName</option>
									}
								}*@
							@if (surveyInstruments != null)
							{
								@foreach (ModelClientShared.SurveyInstrument surveyInstrument in surveyInstruments.Values)
								{
									<option>@surveyInstrument.Name</option>
								}
							}
						</select>

						@*@if (surveyProgramsList[i].SurveyRunsList != null)
								{
									@foreach (SurveyRun run in surveyProgramsList[i].SurveyRunsList)
									{
								<tr>
									<span class="StartDepth" hidden="@IsSurveyProgramDisplayHidden[i]">@run.SurveyInstrument.Name</span>
								</tr>
							}
								}
								@if (surveyProgramsList[i].SurveyRunsList != null && surveyInstruments != null && surveyInstruments.Count > 0)
								{
									@foreach (SurveyRun run in updatedSurveyProgram.SurveyRunsList)
									{
										<tr>
											<select hidden="@IsSurveyProgramInputHidden[i]" @bind="@run.SurveyInstrument.Name">
												@foreach (KeyValuePair<int, NORCE.Drilling.SurveyInstrument.ModelClientShared.SurveyInstrument> pair in surveyInstruments)
												{
													@if (!string.IsNullOrEmpty(run.SurveyInstrument.Name) && run.SurveyInstrument.Name.Equals(pair.Value.Name))
													{
														<option selected>@pair.Value.Name</option>
													}
													else
													{
														<option>@pair.Value.Name</option>
													}
												}
											</select>
										</tr>
									}
								}*@

					</td>
					<td>
						<button class="btn btn-primary" hidden="@IsSurveyStationEditButtonHidden[i]" @onclick="@(() => EditSurveyStation(local))">Edit</button>
						<button class="btn btn-primary" hidden="@IsSurveyStationDeleteButtonHidden[i]" @onclick="@(() => DeleteSurveyStation(local))">Delete</button>
						<button class="btn btn-primary" hidden="@IsSurveyStationUpdateButtonHidden[i]" @onclick="@(() => UpdateSurveyStation(local))">Update</button>
						<button class="btn btn-primary" hidden="@IsSurveyStationCancelButtonHidden[i]" @onclick="@(() => CancelSurveyStation(local))">Cancel</button>
					</td>
				</tr>
			}
		</tbody>
	</table>
}

@code {
	private HttpClient httpTrajectory;
	private List<bool> IsTrajectoryDisplayHidden;
	private List<bool> IsTrajectoryInputHidden;
	private List<bool> IsTrajectoryEditButtonHidden;
	private List<bool> IsTrajectoryDeleteButtonHidden;
	private List<bool> IsTrajectoryUpdateButtonHidden;
	private List<bool> IsTrajectoryCancelButtonHidden;
	private List<bool> IsSurveyStationDisplayHidden;
	private List<bool> IsSurveyStationInputHidden;
	private List<bool> IsSurveyStationEditButtonHidden;
	private List<bool> IsSurveyStationDeleteButtonHidden;
	private List<bool> IsSurveyStationUpdateButtonHidden;
	private List<bool> IsSurveyStationCancelButtonHidden;
	//private List<bool> IsResultDisplayHidden;
	//private List<bool> IsResultInputHidden;
	private bool IsTrajectoryAddInput;
	private bool IsTableSurveyListHidden;
	private bool IsTableResultHidden;

	private HttpClient httpField;
	private List<Tuple<int, string, NORCE.Drilling.Field.ModelClientShared.Field>> fields = null;
	private HttpClient httpCluster;
	private Dictionary<int, NORCE.Drilling.Cluster.ModelClientShared.Cluster> clusters = null;
	private HttpClient httpWell;
	private Dictionary<int, NORCE.Drilling.Well.ModelClientShared.Well> wells = null;
	private Dictionary<int, NORCE.Drilling.WellBore.ModelClientShared.WellBore> wellBores;
	private List<NORCE.Drilling.Trajectory.ModelClientShared.Trajectory> trajectories;
	private List<NORCE.Drilling.Trajectory.ModelClientShared.SurveyStation> surveyStations;
	private List<string> surveyInstrumentNames = new List<string>();
	private int[] surveyInstrumentIDs;
	private Dictionary<int, ModelClientShared.SurveyInstrument> surveyInstruments = null;
	private Dictionary<int, NORCE.Drilling.SurveyProgram.ModelClientShared.SurveyProgram> surveyPrograms;
	private NORCE.Drilling.SurveyProgram.ModelClientShared.SurveyProgram surveyProgram;

	private HttpClient httpWellBore;
	private HttpClient httpSurveyInstrument;
	private HttpClient httpSurveyProgram;
	private string trajectoryName;
	private string editedFieldName = null;
	private string editedClusterName = null;
	private string editedSlotName = null;
	private string editedWellName = null;
	private string editedWellBoreName = null;
	private static int extraSurveyStationCount = 20;

	private NORCE.Drilling.Trajectory.ModelClientShared.Trajectory editedTrajectory;
	private NORCE.Drilling.Trajectory.ModelClientShared.Trajectory updatedTrajectory;
	private NORCE.Drilling.Trajectory.ModelClientShared.SurveyStation updatedSurveyStation;
	public bool boolvalue { get; set; }
	public List<bool> surveyProgramBoolvalues { get; set; }

	protected override async Task OnInitializedAsync()
	{
		try
		{
			if (surveyProgramBoolvalues == null)
			{
				surveyProgramBoolvalues = new List<bool>();
				surveyProgramBoolvalues.Add(false);
				surveyProgramBoolvalues.Add(false);
			}
			if (editedTrajectory == null)
			{
				editedTrajectory = new NORCE.Drilling.Trajectory.ModelClientShared.Trajectory();
				editedTrajectory.ID = -1;
			}
			if (updatedTrajectory == null)
			{
				updatedTrajectory = new NORCE.Drilling.Trajectory.ModelClientShared.Trajectory();
			}
			if (updatedSurveyStation == null)
			{
				updatedSurveyStation = new SurveyStation();
				updatedSurveyStation.MdWGS84 = 0.0;
				updatedSurveyStation.Incl = 0.0;
				updatedSurveyStation.AzWGS84 = 0.0;
				updatedSurveyStation.SurveyTool = new SurveyInstrument();
			}
			if (surveyStations == null)
			{
				surveyStations = new List<SurveyStation>();
			}
			if (IsSurveyStationInputHidden == null)
			{
				IsSurveyStationInputHidden = new List<bool>();
			}
			if (IsSurveyStationDisplayHidden == null)
			{
				IsSurveyStationDisplayHidden = new List<bool>();
			}
			if (IsSurveyStationEditButtonHidden == null)
			{
				IsSurveyStationEditButtonHidden = new List<bool>();
			}
			if (IsSurveyStationDeleteButtonHidden == null)
			{
				IsSurveyStationDeleteButtonHidden = new List<bool>();
			}
			if (IsSurveyStationUpdateButtonHidden == null)
			{
				IsSurveyStationUpdateButtonHidden = new List<bool>();
			}
			if (IsSurveyStationCancelButtonHidden == null)
			{
				IsSurveyStationCancelButtonHidden = new List<bool>();
			}
			//if (IsResultInputHidden == null)
			//{
			//	IsResultInputHidden = new List<bool>();
			//}
			//if (IsResultDisplayHidden == null)
			//{
			//	IsResultDisplayHidden = new List<bool>();
			//}

			IsTrajectoryAddInput = false;
			IsTableSurveyListHidden = true;

			#region Trajectories
			int[] initialTrajectoryIDs = null;
			//int[] initialTrajectoryIDs = await LoadTrajectoryIDs(NORCE.Drilling.Trajectory.WebApp.Client.Configuration.TrajectoryHostURL);
			if (initialTrajectoryIDs == null)
			{
				//initialTrajectoryIDs = await LoadTrajectoryIDs("http://host.docker.internal:" + NORCE.Drilling.Trajectory.WebApp.Client.Configuration.InternalTrajectoryHTTPPortNumber + "/");
			}
			if (initialTrajectoryIDs == null)
			{
				initialTrajectoryIDs = await LoadTrajectoryIDs("http://localhost:" + NORCE.Drilling.Trajectory.WebApp.Client.Configuration.InternalTrajectoryHTTPPortNumber + "/");
			}
			if (initialTrajectoryIDs == null)
			{
				initialTrajectoryIDs = await LoadTrajectoryIDs("https://localhost:44369/");
			}
			if (initialTrajectoryIDs != null)
			{
				List<ModelClientShared.Trajectory> tempTrajectories = new List<ModelClientShared.Trajectory>();
				IsTrajectoryDisplayHidden = new List<bool>();
				IsTrajectoryInputHidden = new List<bool>();
				IsTrajectoryEditButtonHidden = new List<bool>();
				IsTrajectoryDeleteButtonHidden = new List<bool>();
				IsTrajectoryUpdateButtonHidden = new List<bool>();
				IsTrajectoryCancelButtonHidden = new List<bool>();
				int maxSurveyCount = 0;
				for (int i = 0; i < initialTrajectoryIDs.Length; i++)
				{
					var a = await httpTrajectory.GetAsync("Trajectories/" + initialTrajectoryIDs[i].ToString());
					if (a.IsSuccessStatusCode && a.Content != null)
					{
						string str = await a.Content.ReadAsStringAsync();
						if (!string.IsNullOrEmpty(str))
						{
							ModelClientShared.Trajectory trajectory = Newtonsoft.Json.JsonConvert.DeserializeObject<ModelClientShared.Trajectory>(str);
							if (trajectory != null)
							{
								tempTrajectories.Add(trajectory);
								if (trajectory.SurveyList != null)
									if (trajectory.SurveyList.ListOfSurveys != null)
									{
										if (trajectory.SurveyList.ListOfSurveys.Count > maxSurveyCount) maxSurveyCount = trajectory.SurveyList.ListOfSurveys.Count;
									}
								IsTrajectoryDisplayHidden.Add(false);
								IsTrajectoryInputHidden.Add(true);
								IsTrajectoryEditButtonHidden.Add(false);
								IsTrajectoryDeleteButtonHidden.Add(false);
								IsTrajectoryUpdateButtonHidden.Add(true);
								IsTrajectoryCancelButtonHidden.Add(true);
							}
						}
					}
				}
				if (maxSurveyCount == 0)
				{
					extraSurveyStationCount += extraSurveyStationCount;
				}
				//surveyStations.Clear();
				for (int i = surveyStations.Count; i < maxSurveyCount; i++)
				{
					//SurveyStation surveyStation = new SurveyStation();
					//surveyStation.MD = 0.0;
					//surveyStation.Incl = 0.0;
					//surveyStation.AzWGS84 = 0.0;
					//surveyStations.Add(surveyStation);
					//IsSurveyStationDisplayHidden.Add(false);
					//IsSurveyStationInputHidden.Add(true);
					//IsSurveyStationEditButtonHidden.Add(false);
					//IsSurveyStationDeleteButtonHidden.Add(false);
					//IsSurveyStationUpdateButtonHidden.Add(true);
					//IsSurveyStationCancelButtonHidden.Add(true);
					//IsResultDisplayHidden.Add(false);
					//IsResultInputHidden.Add(true);
				}
				if (tempTrajectories != null)
				{
					trajectories = new List<ModelClientShared.Trajectory>();
					var trajectoriesOrdered = tempTrajectories.OrderBy(x => x.Name);
					foreach (NORCE.Drilling.Trajectory.ModelClientShared.Trajectory t in trajectoriesOrdered)
					{
						trajectories.Add(t);
					}
				}
			}
			#endregion

			#region fields
			if (fields == null)
			{
				//	if (NORCE.Drilling.Trajectory.WebApp.Client.ConfigurationManager.Instance.Configuration != null &&
				//		!string.IsNullOrEmpty(NORCE.Drilling.Trajectory.WebApp.Client.ConfigurationManager.Instance.Configuration.HostURL))
				{
					fields = await LoadFields(NORCE.Drilling.Trajectory.WebApp.Client.Configuration.FieldHostURL);
				}
				if (fields == null)
				{
					//if (NORCE.Drilling.Trajectory.WebApp.Client.ConfigurationManager.Instance.Configuration != null &&
					//	NORCE.Drilling.Trajectory.WebApp.Client.ConfigurationManager.Instance.Configuration.InternalHTTPPortNumberField > 0)
					{
						//fields = await LoadFields("http://host.docker.internal:" + NORCE.Drilling.Trajectory.WebApp.Client.Configuration.InternalHTTPPortNumberField + "/");
					}
				}
				if (fields == null)
				{
					//if (NORCE.Drilling.Trajectory.WebApp.Client.ConfigurationManager.Instance.Configuration != null &&
					//	NORCE.Drilling.Trajectory.WebApp.Client.ConfigurationManager.Instance.Configuration.InternalHTTPPortNumberField > 0)
					{
						fields = await LoadFields("http://localhost:" + NORCE.Drilling.Trajectory.WebApp.Client.Configuration.InternalHTTPPortNumberField + "/");
					}
				}
				if (fields != null)
				{
					fields.Insert(0, new Tuple<int, string, NORCE.Drilling.Field.ModelClientShared.Field>(-1, null, null));
				}
			}
			#endregion

			#region clusters
			if (clusters == null)
			{
				Dictionary<int, NORCE.Drilling.Cluster.ModelClientShared.Cluster> tempClusters = null;
				//if (NORCE.Drilling.Trajectory.WebApp.Client.ConfigurationManager.Instance.Configuration != null &&
				//	!string.IsNullOrEmpty(NORCE.Drilling.Trajectory.WebApp.Client.ConfigurationManager.Instance.Configuration.HostURL))
				{
					tempClusters = await LoadClusters(NORCE.Drilling.Trajectory.WebApp.Client.Configuration.ClusterHostURL);
				}
				if (tempClusters == null)
				{
					//if (NORCE.Drilling.Trajectory.WebApp.Client.ConfigurationManager.Instance.Configuration != null &&
					//	NORCE.Drilling.Trajectory.WebApp.Client.ConfigurationManager.Instance.Configuration.InternalHTTPPortNumberCluster > 0)
					{
						//tempClusters = await LoadClusters("http://host.docker.internal:" + NORCE.Drilling.Trajectory.WebApp.Client.Configuration.InternalHTTPPortNumberCluster + "/");
					}
				}
				if (tempClusters == null)
				{
					//if (NORCE.Drilling.Trajectory.WebApp.Client.ConfigurationManager.Instance.Configuration != null &&
					//	NORCE.Drilling.Trajectory.WebApp.Client.ConfigurationManager.Instance.Configuration.InternalHTTPPortNumberCluster > 0)
					{
						tempClusters = await LoadClusters("http://localhost:" + NORCE.Drilling.Trajectory.WebApp.Client.Configuration.InternalHTTPPortNumberCluster + "/");
					}
				}
				if (tempClusters != null)
				{
					clusters = new Dictionary<int, Cluster.ModelClientShared.Cluster>();
					clusters.Add(0, new Cluster.ModelClientShared.Cluster());
					var clustersOrdered = tempClusters.OrderBy(x => x.Key);
					foreach (KeyValuePair<int, NORCE.Drilling.Cluster.ModelClientShared.Cluster> p in clustersOrdered)
					{
						clusters.Add(p.Key, p.Value);
					}
				}
			}
			#endregion

			#region wells
			if (wells == null)
			{
				Dictionary<int, NORCE.Drilling.Well.ModelClientShared.Well> tempWells = null;
				//if (NORCE.Drilling.Trajectory.WebApp.Client.ConfigurationManager.Instance.Configuration != null &&
				//	!string.IsNullOrEmpty(NORCE.Drilling.Trajectory.WebApp.Client.ConfigurationManager.Instance.Configuration.HostURL))
				{
					tempWells = await LoadWells(NORCE.Drilling.Trajectory.WebApp.Client.Configuration.WellHostURL);
				}
				if (tempWells == null)
				{
					//if (NORCE.Drilling.Trajectory.WebApp.Client.ConfigurationManager.Instance.Configuration != null &&
					//	NORCE.Drilling.Trajectory.WebApp.Client.ConfigurationManager.Instance.Configuration.InternalHTTPPortNumberWell > 0)
					{
						//tempWells = await LoadWells("http://host.docker.internal:" + NORCE.Drilling.Trajectory.WebApp.Client.Configuration.InternalHTTPPortNumberWell + "/");
					}
				}
				if (tempWells == null)
				{
					//if (NORCE.Drilling.Trajectory.WebApp.Client.ConfigurationManager.Instance.Configuration != null &&
					//	NORCE.Drilling.Trajectory.WebApp.Client.ConfigurationManager.Instance.Configuration.InternalHTTPPortNumberWell > 0)
					{
						tempWells = await LoadWells("http://localhost:" + NORCE.Drilling.Trajectory.WebApp.Client.Configuration.InternalHTTPPortNumberWell + "/");
					}
				}
				if (tempWells != null)
				{
					wells = new Dictionary<int, Well.ModelClientShared.Well>();
					wells.Add(0, new Well.ModelClientShared.Well());
					var wellsOrdered = tempWells.OrderBy(x => x.Key);
					foreach (KeyValuePair<int, NORCE.Drilling.Well.ModelClientShared.Well> p in wellsOrdered)
					{
						wells.Add(p.Key, p.Value);
					}
				}
			}
			#endregion

			#region wellBores
			if (wellBores == null)
			{
				Dictionary<int, NORCE.Drilling.WellBore.ModelClientShared.WellBore> tempWellBores = null;
				//if (NORCE.Drilling.Trajectory.WebApp.Client.ConfigurationManager.Instance.Configuration != null &&
				//    !string.IsNullOrEmpty(NORCE.Drilling.Trajectory.WebApp.Client.ConfigurationManager.Instance.Configuration.HostURL))
				{
					tempWellBores = await LoadWellBores(NORCE.Drilling.Trajectory.WebApp.Client.Configuration.WellBoreHostURL);
				}
				if (tempWellBores == null)
				{
					//	if (NORCE.Drilling.Trajectory.WebApp.Client.ConfigurationManager.Instance.Configuration != null &&
					//		NORCE.Drilling.Trajectory.WebApp.Client.ConfigurationManager.Instance.Configuration.InternalHTTPPortNumberWellBore > 0)
					{
						//tempWellBores = await LoadWellBores("http://host.docker.internal:" + NORCE.Drilling.Trajectory.WebApp.Client.Configuration.InternalHTTPPortNumberWellBore + "/");
					}
				}
				if (tempWellBores == null)
				{
					//if (NORCE.Drilling.Trajectory.WebApp.Client.ConfigurationManager.Instance.Configuration != null &&
					//	NORCE.Drilling.Trajectory.WebApp.Client.ConfigurationManager.Instance.Configuration.InternalHTTPPortNumberWellBore > 0)
					{
						tempWellBores = await LoadWellBores("http://localhost:" + NORCE.Drilling.Trajectory.WebApp.Client.Configuration.InternalHTTPPortNumberWellBore + "/");
					}
				}
				if (tempWellBores != null)
				{
					wellBores = new Dictionary<int, WellBore.ModelClientShared.WellBore>();
					wellBores.Add(-1, new WellBore.ModelClientShared.WellBore());
					var wellBoresOrdered = tempWellBores.OrderBy(x => x.Key);
					foreach (KeyValuePair<int, NORCE.Drilling.WellBore.ModelClientShared.WellBore> p in wellBoresOrdered)
					{
						wellBores.Add(p.Key, p.Value);
					}
				}
			}
			#endregion

			#region surveyPrograms
			if (surveyPrograms == null)
			{
				Dictionary<int, NORCE.Drilling.SurveyProgram.ModelClientShared.SurveyProgram> tempSurveyProgram = null;
				//if (NORCE.Drilling.Trajectory.WebApp.Client.ConfigurationManager.Instance.Configuration != null &&
				//    !string.IsNullOrEmpty(NORCE.Drilling.Trajectory.WebApp.Client.ConfigurationManager.Instance.Configuration.HostURL))
				{
					//tempSurveyProgram = await LoadSurveyPrograms(NORCE.Drilling.Trajectory.WebApp.Client.Configuration.SurveyProgramHostURL);
				}
				if (tempSurveyProgram == null)
				{
					//	if (NORCE.Drilling.Trajectory.WebApp.Client.ConfigurationManager.Instance.Configuration != null &&
					//		NORCE.Drilling.Trajectory.WebApp.Client.ConfigurationManager.Instance.Configuration.InternalHTTPPortNumberWellBore > 0)
					{
						//tempWellBores = await LoadWellBores("http://host.docker.internal:" + NORCE.Drilling.Trajectory.WebApp.Client.Configuration.InternalHTTPPortNumberWellBore + "/");
					}
				}
				if (tempSurveyProgram == null)
				{
					//if (NORCE.Drilling.Trajectory.WebApp.Client.ConfigurationManager.Instance.Configuration != null &&
					//	NORCE.Drilling.Trajectory.WebApp.Client.ConfigurationManager.Instance.Configuration.InternalHTTPPortNumberWellBore > 0)
					{
						tempSurveyProgram = await LoadSurveyPrograms("http://localhost:" + NORCE.Drilling.Trajectory.WebApp.Client.Configuration.InternalHTTPPortNumberSurveyProgram + "/");
					}
				}
				if (tempSurveyProgram != null)
				{
					surveyPrograms = new Dictionary<int, SurveyProgram.ModelClientShared.SurveyProgram>();
					surveyPrograms.Add(-1, new SurveyProgram.ModelClientShared.SurveyProgram());
					var surveyProgramsOrdered = tempSurveyProgram.OrderBy(x => x.Key);
					foreach (KeyValuePair<int, NORCE.Drilling.SurveyProgram.ModelClientShared.SurveyProgram> p in surveyProgramsOrdered)
					{
						surveyPrograms.Add(p.Key, p.Value);
					}
				}
			}
			#endregion
			#region surveyInstrumentNames
			//surveyInstrumentNames = await LoadSurveyInstrumentNames(NORCE.Drilling.Trajectory.WebApp.Client.Configuration.SurveyInstrumentHostURL);
			if (surveyInstrumentNames == null)
			{
				//surveyInstrumentNames = await LoadSurveyInstrumentNames("http://host.docker.internal:" + NORCE.Drilling.Trajectory.WebApp.Client.Configuration.InternalHTTPPortNumberSurveyInstrument + "/");
			}
			if (surveyInstrumentNames == null || surveyInstrumentNames.Count <= 0)
			{
				surveyInstrumentNames = await LoadSurveyInstrumentNames("http://localhost:" + NORCE.Drilling.Trajectory.WebApp.Client.Configuration.InternalHTTPPortNumberSurveyInstrument + "/");
			}
			if (surveyInstrumentNames == null || surveyInstrumentNames.Count == 0)
			{
				//surveyInstruments = new List<string>();
				//surveyInstruments.Add("GoodMag");
				//surveyInstruments.Add("PoorMag");
				//surveyInstruments.Add("GoodGyro");
				//surveyInstruments.Add("PoorGyro");
				//surveyInstruments[3] = "GoodGyro";
				//surveyInstruments[4] = "PoorGyro";
			}
			#endregion surveyInstrumentNames
			#region surveyInstrumentIDs
			//surveyInstrumentIDs = await LoadSurveyToolIDs(NORCE.Drilling.Trajectory.WebApp.Client.Configuration.SurveyInstrumentHostURL);
			if (surveyInstrumentIDs == null)
			{
				//surveyInstrumentIDs = await LoadSurveyToolIDs("http://host.docker.internal:" + NORCE.Drilling.Trajectory.WebApp.Client.Configuration.InternalHTTPPortNumberSurveyInstrument + "/");
			}
			if (surveyInstrumentIDs == null)
			{
				surveyInstrumentIDs = await LoadSurveyToolIDs("http://localhost:" + NORCE.Drilling.Trajectory.WebApp.Client.Configuration.InternalHTTPPortNumberSurveyInstrument + "/");
			}
			if (surveyInstrumentIDs == null)
			{
				surveyInstrumentIDs = new int[0];
			}
			#endregion surveyInstrumentIDs
			#region surveyInstruments
			//surveyInstruments = await LoadSurveyInstruments(NORCE.Drilling.Trajectory.WebApp.Client.Configuration.SurveyInstrumentHostURL);
			if (surveyInstruments == null)
			{
				//surveyInstruments = await LoadSurveyInstruments("http://host.docker.internal:" + NORCE.Drilling.Trajectory.WebApp.Client.Configuration.InternalHTTPPortNumberSurveyInstrument + "/");
			}
			if (surveyInstruments == null)
			{
				surveyInstruments = await LoadSurveyInstruments("http://localhost:" + NORCE.Drilling.Trajectory.WebApp.Client.Configuration.InternalHTTPPortNumberSurveyInstrument + "/");
			}
			#endregion surveyInstruments
		}
		catch (Exception e)
		{
			System.Console.WriteLine(e.Message);
		}
	}


	private void ToggleCheckbox()
	{

		boolvalue = !boolvalue;

		for (int i = 0; i < surveyProgramBoolvalues.Count; i++)
		{
			bool ch = surveyProgramBoolvalues[i];
			if (ch)
			{
				SurveyProgram.ModelClientShared.SurveyRun run = surveyProgram.SurveyRunsList.ElementAt(i);
				for (int j = 0; j < surveyStations.Count; j++)
				{
					if (surveyStations[j].MdWGS84 >= run.StartMD && surveyStations[j].MdWGS84 <= run.FinalMD)
					{
						foreach (ModelClientShared.SurveyInstrument surveyInstrument in surveyInstruments.Values)
						{
							if (run.SurveyInstrument.Name == surveyInstrument.Name)
							{
								surveyStations[j].SurveyTool = new SurveyInstrument();
								surveyStations[j].SurveyTool = surveyInstrument;
								//surveyInstrument.Copy(updatedSurveyStation.SurveyTool);

							}
						}
						//surveyStations[j].SurveyTool = new SurveyInstrument();
						//surveyStations[j].SurveyTool.Name = run.SurveyInstrument.Name;
						//surveyStations[j].SurveyTool.ModelType = (SurveyInstrumentModelType)run.SurveyInstrument.ModelType;
					}
				}
			}
		}

	}

	private async Task<int[]> LoadTrajectoryIDs(string host)
	{
		int[] initialTrajectoryIDs = null;
		try
		{
			httpTrajectory = new HttpClient();
			httpTrajectory.BaseAddress = new Uri(host + "Trajectory/api/");
			httpTrajectory.DefaultRequestHeaders.Accept.Clear();
			httpTrajectory.DefaultRequestHeaders.Accept.Add(new System.Net.Http.Headers.MediaTypeWithQualityHeaderValue("application/json"));

			var a = await httpTrajectory.GetAsync("Trajectories");
			if (a.IsSuccessStatusCode)
			{
				string str = await a.Content.ReadAsStringAsync();
				if (!string.IsNullOrEmpty(str))
				{
					initialTrajectoryIDs = Newtonsoft.Json.JsonConvert.DeserializeObject<int[]>(str);
				}
			}
		}
		catch (Exception e)
		{
			httpTrajectory = null;
			initialTrajectoryIDs = null;
		}
		return initialTrajectoryIDs;
	}

	private async Task<int[]> LoadSurveyToolIDs(string host)
	{
		int[] initialSurveyInstrumentIDs = null;
		try
		{
			httpSurveyInstrument = new HttpClient();
			httpSurveyInstrument.BaseAddress = new Uri(host + "SurveyInstrument/api/");
			httpSurveyInstrument.DefaultRequestHeaders.Accept.Clear();
			httpSurveyInstrument.DefaultRequestHeaders.Accept.Add(new System.Net.Http.Headers.MediaTypeWithQualityHeaderValue("application/json"));

			var a = await httpSurveyInstrument.GetAsync("SurveyInstruments");
			if (a.IsSuccessStatusCode)
			{
				string str = await a.Content.ReadAsStringAsync();
				if (!string.IsNullOrEmpty(str))
				{
					initialSurveyInstrumentIDs = Newtonsoft.Json.JsonConvert.DeserializeObject<int[]>(str);
				}
			}
		}
		catch (Exception e)
		{
			httpSurveyInstrument = null;
			initialSurveyInstrumentIDs = null;
		}
		return initialSurveyInstrumentIDs;
	}

	private async Task<List<string>> LoadSurveyInstrumentNames(string host)
	{
		int[] initialSurveyInstrumentIDs = null;
		List<string> initialSurveyInstrumentNames = new List<string>();
		try
		{
			httpSurveyInstrument = new HttpClient();
			httpSurveyInstrument.BaseAddress = new Uri(host + "SurveyInstrument/api/");
			httpSurveyInstrument.DefaultRequestHeaders.Accept.Clear();
			httpSurveyInstrument.DefaultRequestHeaders.Accept.Add(new System.Net.Http.Headers.MediaTypeWithQualityHeaderValue("application/json"));

			var a = await httpSurveyInstrument.GetAsync("SurveyInstruments");
			if (a.IsSuccessStatusCode)
			{
				string str = await a.Content.ReadAsStringAsync();
				if (!string.IsNullOrEmpty(str))
				{
					initialSurveyInstrumentIDs = Newtonsoft.Json.JsonConvert.DeserializeObject<int[]>(str);
					for (int i = 0; i < initialSurveyInstrumentIDs.Length; i++)
					{
						var b = await httpSurveyInstrument.GetAsync("SurveyInstruments/" + initialSurveyInstrumentIDs[i].ToString());
						if (b.IsSuccessStatusCode && a.Content != null)
						{
							str = await b.Content.ReadAsStringAsync();
							if (!string.IsNullOrEmpty(str))
							{
								SurveyInstrument surveyInstrument = Newtonsoft.Json.JsonConvert.DeserializeObject<ModelClientShared.SurveyInstrument>(str);
								if (surveyInstrument != null)
								{
									initialSurveyInstrumentNames.Add(surveyInstrument.Name);
								}
							}
						}
					}
				}
			}
		}
		catch (Exception e)
		{
			httpSurveyInstrument = null;
			initialSurveyInstrumentNames = null;
		}
		return initialSurveyInstrumentNames;
	}

	private async Task<Dictionary<int, ModelClientShared.SurveyInstrument>> LoadSurveyInstruments(string host)
	{
		Dictionary<int, ModelClientShared.SurveyInstrument> initialSurveyInstruments = null;
		try
		{
			httpSurveyInstrument = new HttpClient();
			httpSurveyInstrument.BaseAddress = new Uri(host + "SurveyInstrument/api/");
			httpSurveyInstrument.DefaultRequestHeaders.Accept.Clear();
			httpSurveyInstrument.DefaultRequestHeaders.Accept.Add(new System.Net.Http.Headers.MediaTypeWithQualityHeaderValue("application/json"));

			var a = await httpSurveyInstrument.GetAsync("SurveyInstruments");
			if (a.IsSuccessStatusCode)
			{
				string str = await a.Content.ReadAsStringAsync();
				if (!string.IsNullOrEmpty(str))
				{
					int[] initialSurveyInstrumentIDs = Newtonsoft.Json.JsonConvert.DeserializeObject<int[]>(str);
					if (initialSurveyInstrumentIDs != null && initialSurveyInstrumentIDs.Length > 0)
					{
						initialSurveyInstruments = new Dictionary<int, ModelClientShared.SurveyInstrument>();
						for (int i = 0; i < initialSurveyInstrumentIDs.Length; i++)
						{
							int id = initialSurveyInstrumentIDs[i];
							a = await httpSurveyInstrument.GetAsync("SurveyInstruments/" + id);
							if (a.IsSuccessStatusCode)
							{
								str = await a.Content.ReadAsStringAsync();
								if (!string.IsNullOrEmpty(str))
								{
									ModelClientShared.SurveyInstrument downloadedSurveyInstrument = Newtonsoft.Json.JsonConvert.DeserializeObject<ModelClientShared.SurveyInstrument>(str);
									if (downloadedSurveyInstrument != null && !string.IsNullOrEmpty(downloadedSurveyInstrument.Name))
									{
										initialSurveyInstruments.Add(id, downloadedSurveyInstrument);
									}
								}
							}
						}
					}
				}
			}
		}
		catch (Exception e)
		{
			httpSurveyInstrument = null;
			initialSurveyInstruments = null;
		}
		return initialSurveyInstruments;
	}

	private async Task<Dictionary<int, NORCE.Drilling.SurveyInstrument.ModelClientShared.SurveyInstrument>> LoadSurveyInstrumentsTrue(string host)
	{
		Dictionary<int, NORCE.Drilling.SurveyInstrument.ModelClientShared.SurveyInstrument> initialSurveyInstruments = null;
		try
		{
			httpSurveyInstrument = new HttpClient();
			httpSurveyInstrument.BaseAddress = new Uri(host + "SurveyInstrument/api/");
			httpSurveyInstrument.DefaultRequestHeaders.Accept.Clear();
			httpSurveyInstrument.DefaultRequestHeaders.Accept.Add(new System.Net.Http.Headers.MediaTypeWithQualityHeaderValue("application/json"));

			var a = await httpSurveyInstrument.GetAsync("SurveyInstruments");
			if (a.IsSuccessStatusCode)
			{
				string str = await a.Content.ReadAsStringAsync();
				if (!string.IsNullOrEmpty(str))
				{
					int[] initialSurveyInstrumentIDs = Newtonsoft.Json.JsonConvert.DeserializeObject<int[]>(str);
					if (initialSurveyInstrumentIDs != null && initialSurveyInstrumentIDs.Length > 0)
					{
						initialSurveyInstruments = new Dictionary<int, NORCE.Drilling.SurveyInstrument.ModelClientShared.SurveyInstrument>();
						for (int i = 0; i < initialSurveyInstrumentIDs.Length; i++)
						{
							int id = initialSurveyInstrumentIDs[i];
							a = await httpSurveyInstrument.GetAsync("SurveyInstruments/" + id);
							if (a.IsSuccessStatusCode)
							{
								str = await a.Content.ReadAsStringAsync();
								if (!string.IsNullOrEmpty(str))
								{
									NORCE.Drilling.SurveyInstrument.ModelClientShared.SurveyInstrument downloadedSurveyInstrument = Newtonsoft.Json.JsonConvert.DeserializeObject<NORCE.Drilling.SurveyInstrument.ModelClientShared.SurveyInstrument>(str);
									if (downloadedSurveyInstrument != null && !string.IsNullOrEmpty(downloadedSurveyInstrument.Name))
									{
										initialSurveyInstruments.Add(id, downloadedSurveyInstrument);
									}
								}
							}
						}
					}
				}
			}
		}
		catch (Exception e)
		{
			httpSurveyInstrument = null;
			initialSurveyInstruments = null;
		}
		return initialSurveyInstruments;
	}

	private async Task<List<Tuple<int, string, NORCE.Drilling.Field.ModelClientShared.Field>>> LoadFields(string host)
	{
		List<Tuple<int, string, NORCE.Drilling.Field.ModelClientShared.Field>> initialFields = null;
		try
		{
			httpField = new HttpClient();
			httpField.BaseAddress = new Uri(host + "Field/api/");
			httpField.DefaultRequestHeaders.Accept.Clear();
			httpField.DefaultRequestHeaders.Accept.Add(new System.Net.Http.Headers.MediaTypeWithQualityHeaderValue("application/json"));

			var a = await httpField.GetAsync("Fields");
			if (a.IsSuccessStatusCode)
			{
				string str = await a.Content.ReadAsStringAsync();
				if (!string.IsNullOrEmpty(str))
				{
					int[] initialFieldIDs = Newtonsoft.Json.JsonConvert.DeserializeObject<int[]>(str);
					if (initialFieldIDs != null && initialFieldIDs.Length > 0)
					{
						initialFields = new List<Tuple<int, string, NORCE.Drilling.Field.ModelClientShared.Field>>();
						for (int i = 0; i < initialFieldIDs.Length; i++)
						{
							int id = initialFieldIDs[i];
							a = await httpField.GetAsync("Fields/" + id);
							if (a.IsSuccessStatusCode)
							{
								str = await a.Content.ReadAsStringAsync();
								if (!string.IsNullOrEmpty(str))
								{
									NORCE.Drilling.Field.ModelClientShared.Field downloadedField = Newtonsoft.Json.JsonConvert.DeserializeObject<NORCE.Drilling.Field.ModelClientShared.Field>(str);
									if (downloadedField != null && !string.IsNullOrEmpty(downloadedField.Name))
									{
										initialFields.Add(new Tuple<int, string, NORCE.Drilling.Field.ModelClientShared.Field>(id, downloadedField.Name, downloadedField));
									}
								}
							}
						}
					}
				}
			}
		}
		catch (Exception e)
		{
			httpField = null;
			initialFields = null;
		}
		return initialFields;
	}

	private async Task<Dictionary<int, NORCE.Drilling.Cluster.ModelClientShared.Cluster>> LoadClusters(string host)
	{
		Dictionary<int, NORCE.Drilling.Cluster.ModelClientShared.Cluster> initialClusters = null;
		try
		{
			httpCluster = new HttpClient();
			httpCluster.BaseAddress = new Uri(host + "Cluster/api/");
			httpCluster.DefaultRequestHeaders.Accept.Clear();
			httpCluster.DefaultRequestHeaders.Accept.Add(new System.Net.Http.Headers.MediaTypeWithQualityHeaderValue("application/json"));

			var a = await httpCluster.GetAsync("Clusters");
			if (a.IsSuccessStatusCode)
			{
				string str = await a.Content.ReadAsStringAsync();
				if (!string.IsNullOrEmpty(str))
				{
					int[] initialClusterIDs = Newtonsoft.Json.JsonConvert.DeserializeObject<int[]>(str);
					if (initialClusterIDs != null && initialClusterIDs.Length > 0)
					{
						initialClusters = new Dictionary<int, NORCE.Drilling.Cluster.ModelClientShared.Cluster>();
						for (int i = 0; i < initialClusterIDs.Length; i++)
						{
							int id = initialClusterIDs[i];
							a = await httpCluster.GetAsync("Clusters/" + id);
							if (a.IsSuccessStatusCode)
							{
								str = await a.Content.ReadAsStringAsync();
								if (!string.IsNullOrEmpty(str))
								{
									NORCE.Drilling.Cluster.ModelClientShared.Cluster downloadedCluster = Newtonsoft.Json.JsonConvert.DeserializeObject<NORCE.Drilling.Cluster.ModelClientShared.Cluster>(str);
									if (downloadedCluster != null && !string.IsNullOrEmpty(downloadedCluster.Name))
									{
										initialClusters.Add(id, downloadedCluster);
									}
								}
							}
						}
					}
				}
			}
		}
		catch (Exception e)
		{
			httpCluster = null;
			initialClusters = null;
		}
		return initialClusters;
	}

	private async Task<Dictionary<int, NORCE.Drilling.Well.ModelClientShared.Well>> LoadWells(string host)
	{
		Dictionary<int, NORCE.Drilling.Well.ModelClientShared.Well> initialWells = null;
		try
		{
			httpWell = new HttpClient();
			httpWell.BaseAddress = new Uri(host + "Well/api/");
			httpWell.DefaultRequestHeaders.Accept.Clear();
			httpWell.DefaultRequestHeaders.Accept.Add(new System.Net.Http.Headers.MediaTypeWithQualityHeaderValue("application/json"));

			var a = await httpWell.GetAsync("Wells");
			if (a.IsSuccessStatusCode)
			{
				string str = await a.Content.ReadAsStringAsync();
				if (!string.IsNullOrEmpty(str))
				{
					int[] initialWellIDs = Newtonsoft.Json.JsonConvert.DeserializeObject<int[]>(str);
					if (initialWellIDs != null && initialWellIDs.Length > 0)
					{
						initialWells = new Dictionary<int, NORCE.Drilling.Well.ModelClientShared.Well>();
						for (int i = 0; i < initialWellIDs.Length; i++)
						{
							int id = initialWellIDs[i];
							a = await httpWell.GetAsync("Wells/" + id);
							if (a.IsSuccessStatusCode)
							{
								str = await a.Content.ReadAsStringAsync();
								if (!string.IsNullOrEmpty(str))
								{
									NORCE.Drilling.Well.ModelClientShared.Well downloadedWell = Newtonsoft.Json.JsonConvert.DeserializeObject<NORCE.Drilling.Well.ModelClientShared.Well>(str);
									if (downloadedWell != null && !string.IsNullOrEmpty(downloadedWell.Name))
									{
										initialWells.Add(id, downloadedWell);
									}
								}
							}
						}
					}
				}
			}
		}
		catch (Exception e)
		{
			httpWell = null;
			initialWells = null;
		}
		return initialWells;
	}

	private async Task<Dictionary<int, NORCE.Drilling.WellBore.ModelClientShared.WellBore>> LoadWellBores(string host)
	{
		Dictionary<int, NORCE.Drilling.WellBore.ModelClientShared.WellBore> initialWellBores = null;
		try
		{
			httpWellBore = new HttpClient();
			httpWellBore.BaseAddress = new Uri(host + "WellBore/api/");
			httpWellBore.DefaultRequestHeaders.Accept.Clear();
			httpWellBore.DefaultRequestHeaders.Accept.Add(new System.Net.Http.Headers.MediaTypeWithQualityHeaderValue("application/json"));

			var a = await httpWellBore.GetAsync("WellBores");
			if (a.IsSuccessStatusCode)
			{
				string str = await a.Content.ReadAsStringAsync();
				if (!string.IsNullOrEmpty(str))
				{
					int[] initialWellBoreIDs = Newtonsoft.Json.JsonConvert.DeserializeObject<int[]>(str);
					if (initialWellBoreIDs != null && initialWellBoreIDs.Length > 0)
					{
						initialWellBores = new Dictionary<int, NORCE.Drilling.WellBore.ModelClientShared.WellBore>();
						for (int i = 0; i < initialWellBoreIDs.Length; i++)
						{
							int id = initialWellBoreIDs[i];
							a = await httpWellBore.GetAsync("WellBores/" + id);
							if (a.IsSuccessStatusCode)
							{
								str = await a.Content.ReadAsStringAsync();
								if (!string.IsNullOrEmpty(str))
								{
									NORCE.Drilling.WellBore.ModelClientShared.WellBore downloadedWellBore = Newtonsoft.Json.JsonConvert.DeserializeObject<NORCE.Drilling.WellBore.ModelClientShared.WellBore>(str);
									if (downloadedWellBore != null && !string.IsNullOrEmpty(downloadedWellBore.Name))
									{
										initialWellBores.Add(id, downloadedWellBore);
									}
								}
							}
						}
					}
				}
			}
		}
		catch (Exception e)
		{
			httpWellBore = null;
			initialWellBores = null;
		}
		return initialWellBores;
	}

	private async Task<Dictionary<int, NORCE.Drilling.SurveyProgram.ModelClientShared.SurveyProgram>> LoadSurveyPrograms(string host)
	{
		Dictionary<int, NORCE.Drilling.SurveyProgram.ModelClientShared.SurveyProgram> initialSurveyPrograms = null;
		try
		{
			httpSurveyProgram = new HttpClient();
			httpSurveyProgram.BaseAddress = new Uri(host + "SurveyProgram/api/");
			httpSurveyProgram.DefaultRequestHeaders.Accept.Clear();
			httpSurveyProgram.DefaultRequestHeaders.Accept.Add(new System.Net.Http.Headers.MediaTypeWithQualityHeaderValue("application/json"));

			var a = await httpSurveyProgram.GetAsync("SurveyPrograms");
			if (a.IsSuccessStatusCode)
			{
				string str = await a.Content.ReadAsStringAsync();
				if (!string.IsNullOrEmpty(str))
				{
					int[] initialSurveyProgramIDs = Newtonsoft.Json.JsonConvert.DeserializeObject<int[]>(str);
					if (initialSurveyProgramIDs != null && initialSurveyProgramIDs.Length > 0)
					{
						initialSurveyPrograms = new Dictionary<int, NORCE.Drilling.SurveyProgram.ModelClientShared.SurveyProgram>();
						for (int i = 0; i < initialSurveyProgramIDs.Length; i++)
						{
							int id = initialSurveyProgramIDs[i];
							a = await httpSurveyProgram.GetAsync("SurveyPrograms/" + id);
							if (a.IsSuccessStatusCode)
							{
								str = await a.Content.ReadAsStringAsync();
								if (!string.IsNullOrEmpty(str))
								{
									NORCE.Drilling.SurveyProgram.ModelClientShared.SurveyProgram downloadedSurveyProgram = Newtonsoft.Json.JsonConvert.DeserializeObject<NORCE.Drilling.SurveyProgram.ModelClientShared.SurveyProgram>(str);
									if (downloadedSurveyProgram != null && !string.IsNullOrEmpty(downloadedSurveyProgram.Name))
									{
										initialSurveyPrograms.Add(downloadedSurveyProgram.WellboreID, downloadedSurveyProgram);
									}
								}
							}
						}
					}
				}
			}
		}
		catch (Exception e)
		{
			httpSurveyProgram = null;
			initialSurveyPrograms = null;
		}
		return initialSurveyPrograms;
	}

	private void Edit(int idx)
	{
		if (trajectories != null && idx >= 0 && idx < trajectories.Count)
		{
			IsTrajectoryAddInput = true;
			for (int i = 0; i < IsTrajectoryDisplayHidden.Count; i++)
			{
				if (i == idx)
				{
					IsTrajectoryDisplayHidden[i] = true;
					IsTrajectoryInputHidden[i] = false;
					IsTrajectoryEditButtonHidden[i] = true;
					IsTrajectoryDeleteButtonHidden[i] = true;
					IsTrajectoryUpdateButtonHidden[i] = false;
					IsTrajectoryCancelButtonHidden[i] = false;
				}
				else
				{
					IsTrajectoryDisplayHidden[i] = false;
					IsTrajectoryInputHidden[i] = true;
					IsTrajectoryEditButtonHidden[i] = true;
					IsTrajectoryDeleteButtonHidden[i] = true;
					IsTrajectoryUpdateButtonHidden[i] = true;
					IsTrajectoryCancelButtonHidden[i] = true;
				}
			}
			IsTableSurveyListHidden = false;

			trajectories[idx].Copy(updatedTrajectory);
			if (updatedTrajectory != null)
			{
				// The ID is not copied by the Copy method
				updatedTrajectory.ID = trajectories[idx].ID;
				trajectoryName = updatedTrajectory.Name;
				NORCE.Drilling.Cluster.ModelClientShared.Cluster updatedWell = clusters[wells[wellBores[updatedTrajectory.WellboreID].WellID].ClusterID];
				editedWellName = wells[wellBores[updatedTrajectory.WellboreID].WellID]?.Name ?? null;
				editedWellBoreName = wellBores[updatedTrajectory.WellboreID]?.Name ?? null;
				NORCE.Drilling.Cluster.ModelClientShared.Cluster updatedCluster = clusters[wells[wellBores[updatedTrajectory.WellboreID].WellID].ClusterID];
				NORCE.Drilling.SurveyProgram.ModelClientShared.SurveyProgram updatedSurveyProgram = null;
				surveyProgram = null;
				if (surveyPrograms != null)
				{
					if (surveyPrograms.TryGetValue(updatedTrajectory.WellboreID, out updatedSurveyProgram))

					{
						updatedSurveyProgram = surveyPrograms[updatedTrajectory.WellboreID];
					}
					if (updatedSurveyProgram != null)
					{
						surveyProgram = surveyPrograms[updatedTrajectory.WellboreID];
						if (updatedSurveyProgram.SurveyRunsList != null && updatedSurveyProgram.SurveyRunsList.Count > 0)
						{
							surveyProgramBoolvalues.Clear();
							for (int i = 0; i < updatedSurveyProgram.SurveyRunsList.Count; i++)
							{
								surveyProgramBoolvalues.Add(false);
							}
						}

					}
				}
				if (updatedCluster != null)
				{
					editedClusterName = updatedCluster.Name;
					editedFieldName = null;
					if (updatedCluster.Field != null)
					{
						editedFieldName = updatedCluster.Field.Name;
					}
					editedSlotName = null;
					NORCE.Drilling.Cluster.ModelClientShared.Slot slot = updatedCluster.GetSlot(wells[wellBores[updatedTrajectory.WellboreID].WellID].SlotID);
					if (slot != null)
					{
						editedSlotName = slot.Name;
					}
				}
				else
				{
					editedFieldName = null;
					editedClusterName = null;
					editedSlotName = null;
				}

				surveyStations = new List<SurveyStation>();
				IsSurveyStationDisplayHidden = new List<bool>();
				IsSurveyStationInputHidden = new List<bool>();
				IsSurveyStationEditButtonHidden = new List<bool>();
				IsSurveyStationDeleteButtonHidden = new List<bool>();
				IsSurveyStationUpdateButtonHidden = new List<bool>();
				IsSurveyStationCancelButtonHidden = new List<bool>();
				//IsResultDisplayHidden = new List<bool>();
				//IsResultInputHidden = new List<bool>();
				if (updatedTrajectory.SurveyList != null && updatedTrajectory.SurveyList.ListOfSurveys != null)
				{
					foreach (SurveyStation station in updatedTrajectory.SurveyList.ListOfSurveys)
					{
						surveyStations.Add(station);
						IsSurveyStationDisplayHidden.Add(false);
						IsSurveyStationInputHidden.Add(true);
						IsSurveyStationEditButtonHidden.Add(false);
						IsSurveyStationDeleteButtonHidden.Add(false);
						IsSurveyStationUpdateButtonHidden.Add(true);
						IsSurveyStationCancelButtonHidden.Add(true);
						//IsResultDisplayHidden.Add(false);
						//IsResultInputHidden.Add(true);
					}
				}
				if (surveyStations.Count == 0)
				{
					double MDi = 0.0;
					for (int i = 0; i < extraSurveyStationCount; i++)
					{
						SurveyStation st = new SurveyStation();
						st.MdWGS84 = MDi;
						st.AzWGS84 = 0.0;
						st.Incl = 0.0;
						st.NorthOfWellHead = 0.0;
						st.EastOfWellHead = 0.0;
						st.TvdWGS84 = MDi;
						surveyStations.Add(st);
						IsSurveyStationDisplayHidden.Add(false);
						IsSurveyStationInputHidden.Add(true);
						IsSurveyStationEditButtonHidden.Add(false);
						IsSurveyStationDeleteButtonHidden.Add(false);
						IsSurveyStationUpdateButtonHidden.Add(true);
						IsSurveyStationCancelButtonHidden.Add(true);
						//IsResultDisplayHidden.Add(false);
						//IsResultInputHidden.Add(true);
						MDi = MDi + 30.0;
					}
				}
			}
			else
			{
				trajectoryName = null;
			}
		}
	}


	private void EditSurveyStation(int idx)
	{
		if (surveyStations != null && idx >= 0 && idx < surveyStations.Count)
		{
			surveyStations[idx].Copy(updatedSurveyStation);
			for (int i = 0; i < IsSurveyStationDisplayHidden.Count; i++)
			{
				if (i == idx)
				{
					IsSurveyStationDisplayHidden[i] = true;
					IsSurveyStationInputHidden[i] = false;
					IsSurveyStationEditButtonHidden[i] = true;
					IsSurveyStationDeleteButtonHidden[i] = true;
					IsSurveyStationUpdateButtonHidden[i] = false;
					IsSurveyStationCancelButtonHidden[i] = false;
					//IsResultDisplayHidden[i] = true;
					//IsResultInputHidden[i] = false;
				}
				else
				{
					IsSurveyStationDisplayHidden[i] = false;
					IsSurveyStationInputHidden[i] = true;
					IsSurveyStationEditButtonHidden[i] = true;
					IsSurveyStationDeleteButtonHidden[i] = true;
					IsSurveyStationUpdateButtonHidden[i] = true;
					IsSurveyStationCancelButtonHidden[i] = true;
					//IsResultDisplayHidden[i] = false;
					//IsResultInputHidden[i] = true;
				}
			}
		}
	}

	private async void Delete(int idx)
	{
		if (trajectories != null && idx >= 0 && idx < trajectories.Count && trajectories[idx] != null && trajectories[idx].ID > 0)
		{
			IsTableSurveyListHidden = true;
			var a = await httpTrajectory.DeleteAsync("Trajectories/" + trajectories[idx].ID);
			if (a.IsSuccessStatusCode)
			{
				await OnInitializedAsync();
				await InvokeAsync(() => { StateHasChanged(); });
			}
		}
	}

	private void DeleteSurveyStation(int idx)
	{
		if (surveyStations != null && idx >= 0 && idx < surveyStations.Count)
		{
			surveyStations[idx].Abscissa = null;
			surveyStations[idx].MdWGS84 = 0;
			surveyStations[idx].Incl = 0;
			surveyStations[idx].AzWGS84 = 0;
		}
	}

	private async void Update(int idx)
	{
		if (trajectories != null && idx >= 0 && idx < trajectories.Count && trajectories[idx].ID >= 0)
		{
			#region transfer edited surveyStations in trajectory
			if (updatedTrajectory.SurveyList == null)
			{
				updatedTrajectory.SurveyList = new SurveyList();
			}
			if (updatedTrajectory.SurveyList.Surveys == null)
			{
				updatedTrajectory.SurveyList.Surveys = new List<SurveyStation>();

			}
			updatedTrajectory.SurveyList.Surveys.Clear();
			if (surveyStations != null)
			{
				for (int i = 0; i < surveyStations.Count; i++)
				{
					if (!string.IsNullOrEmpty(surveyStations[i].MdWGS84.ToString()))
					{
						SurveyStation surveyStation = new SurveyStation();
						surveyStation = surveyStations[i];
						surveyStation.Uncertainty = surveyStations[i].Uncertainty;
						updatedTrajectory.SurveyList.Surveys.Add(surveyStation);
					}
				}
				updatedTrajectory.SurveyList.ListOfSurveys = surveyStations;
			}
			#endregion end transfer edited surveyStations

			#region update WellboreID
			if (!string.IsNullOrEmpty(editedWellBoreName) && wellBores != null)
			{
				foreach (KeyValuePair<int, NORCE.Drilling.WellBore.ModelClientShared.WellBore> pair in wellBores)
				{
					if (editedWellBoreName.Equals(pair.Value.Name))
					{
						updatedTrajectory.WellboreID = pair.Value.ID;
						break;
					}
				}
			}
			#endregion

			// Transfer updated name, description and WellboreID
			updatedTrajectory.Copy(trajectories[idx]);

			StringContent content = new StringContent(trajectories[idx].GetJson(), Encoding.UTF8, "application/json");
			var a = await httpTrajectory.PutAsync("Trajectories/" + trajectories[idx].ID, content);
			editedFieldName = null;
			editedClusterName = null;
			editedSlotName = null;
			editedWellName = null;
			editedWellBoreName = null;

			IsTableSurveyListHidden = true;
			IsTrajectoryAddInput = false;
			for (int i = 0; i < IsTrajectoryDisplayHidden.Count; i++)
			{
				IsTrajectoryDisplayHidden[i] = false;
				IsTrajectoryInputHidden[i] = true;
				IsTrajectoryEditButtonHidden[i] = false;
				IsTrajectoryDeleteButtonHidden[i] = false;
				IsTrajectoryUpdateButtonHidden[i] = true;
				IsTrajectoryCancelButtonHidden[i] = true;
			}
			if (a.IsSuccessStatusCode)
			{
				await OnInitializedAsync();
				await InvokeAsync(() => { StateHasChanged(); });
			}
		}
	}


	private void UpdateSurveyStation(int idx)
	{
		foreach (ModelClientShared.SurveyInstrument surveyInstrument in surveyInstruments.Values)
		{
			if(updatedSurveyStation.SurveyTool.Name== surveyInstrument.Name)
			{
				updatedSurveyStation.SurveyTool = surveyInstrument;
				//surveyInstrument.Copy(updatedSurveyStation.SurveyTool);

			}
		}


		if (surveyStations != null && idx >= 0 && idx < surveyStations.Count)
		{
			updatedSurveyStation.Copy(surveyStations[idx]);
		}
		//updatedSurveyStation.MD = 0;
		//updatedSurveyStation.Incl = 0;
		//updatedSurveyStation.AzWGS84 = 0;
		for (int i = 0; i < IsSurveyStationDisplayHidden.Count; i++)
		{
			IsSurveyStationDisplayHidden[i] = false;
			IsSurveyStationInputHidden[i] = true;
			IsSurveyStationEditButtonHidden[i] = false;
			IsSurveyStationDeleteButtonHidden[i] = false;
			IsSurveyStationUpdateButtonHidden[i] = true;
			IsSurveyStationCancelButtonHidden[i] = true;
			//IsResultDisplayHidden[i] = false;
			//IsResultInputHidden[i] = true;
		}
	}

	private void Cancel(int idx)
	{
		if (trajectories != null && idx >= 0 && idx < trajectories.Count)
		{
			IsTableSurveyListHidden = true;
			IsTrajectoryAddInput = false;
			editedFieldName = null;
			editedClusterName = null;
			editedSlotName = null;
			editedWellName = null;
			editedWellBoreName = null;
			for (int i = 0; i < IsTrajectoryDisplayHidden.Count; i++)
			{
				IsTrajectoryDisplayHidden[i] = false;
				IsTrajectoryInputHidden[i] = true;
				IsTrajectoryEditButtonHidden[i] = false;
				IsTrajectoryDeleteButtonHidden[i] = false;
				IsTrajectoryUpdateButtonHidden[i] = true;
				IsTrajectoryCancelButtonHidden[i] = true;
			}
		}
	}

	private void CancelSurveyStation(int idx)
	{
		updatedSurveyStation.Abscissa = null;
		updatedSurveyStation.MdWGS84 = 0;
		updatedSurveyStation.Incl = 0;
		updatedSurveyStation.AzWGS84 = 0;
		for (int i = 0; i < IsSurveyStationDisplayHidden.Count; i++)
		{
			IsSurveyStationDisplayHidden[i] = false;
			IsSurveyStationInputHidden[i] = true;
			IsSurveyStationEditButtonHidden[i] = false;
			IsSurveyStationDeleteButtonHidden[i] = false;
			IsSurveyStationUpdateButtonHidden[i] = true;
			IsSurveyStationCancelButtonHidden[i] = true;
			//IsResultDisplayHidden[i] = false;
			//IsResultInputHidden[i] = true;
		}
	}
	private async void Add()
	{
		#region update WellboreID
		if (!string.IsNullOrEmpty(editedWellBoreName) && wellBores != null)
		{
			foreach (KeyValuePair<int, NORCE.Drilling.WellBore.ModelClientShared.WellBore> pair in wellBores)
			{
				if (editedWellBoreName.Equals(pair.Value.Name))
				{
					editedTrajectory.WellboreID = pair.Value.ID;
					break;
				}
			}
		}
		#endregion

		ModelClientShared.Trajectory newTrajectory = new ModelClientShared.Trajectory();
		editedTrajectory.Copy(newTrajectory);
		//Cancel();
		StringContent content = new StringContent(newTrajectory.GetJson(), Encoding.UTF8, "application/json");

		var a = await httpTrajectory.PostAsync("Trajectories", content);
		if (a.IsSuccessStatusCode)
		{
			await OnInitializedAsync();
			await InvokeAsync(() => { StateHasChanged(); });
		}
	}

	private void Cancel()
	{
		if (editedTrajectory != null)
		{
			editedTrajectory.Name = null;
			editedTrajectory.Description = null;
			editedTrajectory.WellboreID = 0;
		}
		editedFieldName = null;
		editedClusterName = null;
		editedSlotName = null;
		editedWellName = null;
		editedWellBoreName = null;
	}

	private async void Copy(int idx)
	{
		ModelClientShared.Trajectory trajectoryCopy = new ModelClientShared.Trajectory();
		trajectories[idx].Copy(trajectoryCopy);
		trajectoryCopy.Name = trajectoryCopy.Name + "Copy";
		trajectoryCopy.ID = -1;
		StringContent content = new StringContent(trajectoryCopy.GetJson(), Encoding.UTF8, "application/json");

		var a = await httpTrajectory.PostAsync("Trajectories", content);
		if (a.IsSuccessStatusCode)
		{
			await OnInitializedAsync();
			await InvokeAsync(() => { StateHasChanged(); });
		}
	}

}


