@page "/SurveyStationUncertainty"
@using System.Text;
@using NORCE.Drilling.Trajectory.WebApp.Client
@using NORCE.Drilling.Trajectory.ModelClientShared;
<h3>SurveyStationUncertainty</h3>



@if (trajectories == null)
{
	<p><em>Loading...</em></p>
}
else
{
	<h2>Trajectory List</h2>

	<table class="table">
		<thead>
			<tr>
				<th>Name</th>
				<th>Description</th>
				<th>Confidence Level</th>
				<th></th>
				<th></th>
				<th class="SurveyProgramCheckBox">Compare</th>
			</tr>
		</thead>
		<tbody>
			@for (int i = 0; i < trajectories.Count; i++)
			{
				var local = i;
				<tr>
					<td>
						<span class="label" >@trajectories[i].Name</span>
					</td>
					<td>
						<span class="label" >@trajectories[i].Description</span>
					</td>
					<td>					
						<span class="label" hidden="@IsConfidenceLevelDisplayHidden[i]">@confidenceLevels[i]</span>
						<input class="text" type="text" hidden="@IsConfidenceLevelInputHidden[i]" @bind="@updatedConfidenceLevel" />
					</td>
					<td>
						<button class="btn btn-primary" hidden="@IsConfidenceLevelEditButtonHidden[i]" @onclick="@(() => EditConfidenceLevel(local))">Edit Confidence Level</button>
						<button class="btn btn-primary" hidden="@IsConfidenceLevelUpdateButtonHidden[i]" @onclick="@(() => UpdateConfidenceLevel(local))">Update Confidence Level</button>
					</td>
					<td>
						<button class="btn btn-primary" @onclick="@(() => Calculate(local))">Calculate</button>
					</td>

					<td>
						<input type="checkbox" @bind="@trajectoryCompareChBoxvalues[local]" />
					</td>
				</tr>
			}
		</tbody>
		
	</table>
	<table class="table" hidden="@IsTableResultHidden">
		<thead></thead>
		<tbody>
			<tr>
				@*<td>
					<Mesh3DPlots XValuesLine="@interpSectionsX"
								 YValuesLine="@interpSectionsY"
								 ZValuesLine="@interpSectionsZ"
								 ValuesNameLine="Trajectory"
								 XValues="@calcSectionsX"
								 YValues="@calcSectionsY"
								 ZValues="@calcSectionsZ"
								 ValuesName="Envelope"
								 XValues2="@calcSectionsX2"
								 YValues2="@calcSectionsY2"
								 ZValues2="@calcSectionsZ2"
								 ValuesName2="Envelope2"
								 XValuesList="@calcSectionsXList"
								 YValuesList="@calcSectionsYList"
								 ZValuesList="@calcSectionsZList"
								 ValuesListColor="blue"
								 ValuesNameList="Ellipses of Uncertianty"
								 XValuesList2="@calcSectionsXList2"
								 YValuesList2="@calcSectionsYList2"
								 ZValuesList2="@calcSectionsZList2"
								 ValuesListColor2="red"
								 ValuesNameList2="Ellipses of Uncertianty Comp"
								 XValuesListCompare="@calcSectionsXListCompare"
								 YValuesListCompare="@calcSectionsYListCompare"
								 ZValuesListCompare="@calcSectionsZListCompare"
								 ValuesListColorCompare="@valueListColorComapre"
								 ValuesNameListCompare="Ellipses of Uncertianty Comp"
								 PlotHeight="800"
								 PlotWidth="800"
								 PlotTitle="Wellbore Position Uncertainty"
								 XAxisTitle="North (m)"
								 YAxisTitle="East (m)"
								 ZAxisTitle="TVD (m)"
								 ZAxisIsReversed="@true"
								 @ref="@trajectorySurface3DPlot"></Mesh3DPlots>
				</td>*@
				<td>
					<Mesh3DPlots XValuesLine="@interpSectionsX"
								 YValuesLine="@interpSectionsY"
								 ZValuesLine="@interpSectionsZ"
								 ValuesNameLine="Trajectory"
								 XValues="@calcSectionsX"
								 YValues="@calcSectionsY"
								 ZValues="@calcSectionsZ"
								 ValuesName="Envelope"
								 XValues2="@calcSectionsX2"
								 YValues2="@calcSectionsY2"
								 ZValues2="@calcSectionsZ2"
								 ValuesName2="Envelope2"
								 XValuesCompare="@calcSectionsXCompare"
								 YValuesCompare="@calcSectionsYCompare"
								 ZValuesCompare="@calcSectionsZCompare"
								 ValuesListColorCompare="@valueListColorCompare"
								 PlotHeight="800"
								 PlotWidth="800"
								 PlotTitle="Wellbore Position Uncertainty"
								 XAxisTitle="North (m)"
								 YAxisTitle="East (m)"
								 ZAxisTitle="TVD (m)"
								 ZAxisIsReversed="@true"
								 @ref="@trajectorySurface3DPlot"></Mesh3DPlots>
				</td>
			</tr>
		</tbody>
	</table>
	<h2 hidden="@IsTableResultHidden">Ellipse Radiuses @trajectoryName</h2>

	<table class="table" hidden="@IsTableResultHidden">
		<thead>
			<tr>
				<th>R1 @trajectoryName</th>
				<th>R2 @trajectoryName</th>
				<th>R1 @trajectoryName2</th>
				<th>R2 @trajectoryName2</th>
				<th></th>
			</tr>
		</thead>
		<tbody>
			@for (int i = 0; i < listRadius.Count; i++)
			{
				List<double> list = listRadius[i];
				List<double> list2 = new List<double>();
				if (listRadius2 != null && listRadius2.Count > i)
				{
					list2 = listRadius2[i];
				}
				if (list[0] != null)
				{
					<tr>
						<td>
							<span class="label" hidden="@IsResultDisplayHidden[i]">@list[0]</span>							
						</td>
						<td>
							<span class="label" hidden="@IsResultDisplayHidden[i]">@list[1]</span>							
						</td>
						<td>
							@if (list2 != null && list2.Count > 0)
							{
								<span class="label" hidden="@IsResultDisplayHidden[i]">@list2[0]</span>								
							}
						</td>
						<td>
							@if (list2 != null && list2.Count > 0)
							{
								<span class="label" hidden="@IsResultDisplayHidden[i]">@list2[1]</span>							
							}
						</td>

					</tr>
				}
			}
		</tbody>
	</table>

}

@code {
	private HttpClient httpTrajectory;
	private List<bool> IsResultDisplayHidden;
	private List<bool> IsResultInputHidden;
	private List<bool> IsConfidenceLevelInputHidden;
	private List<bool> IsConfidenceLevelDisplayHidden;
	private List<bool> IsConfidenceLevelEditButtonHidden;
	private List<bool> IsConfidenceLevelUpdateButtonHidden;
	private bool IsTableResultHidden;
	private bool IsTableResultHidden2;
	private List<NORCE.Drilling.Trajectory.ModelClientShared.Trajectory> trajectories;
	private List<double> confidenceLevels = new List<double>();
	private double updatedConfidenceLevel;
	bool isInitialized = false;
	private List<List<double>> listRadius = new List<List<double>>();
	private List<List<double>> listRadius2 = new List<List<double>>();
	private int currentIndex = 0;
	private string trajectoryName;
	private string trajectoryName2;
	Mesh3DPlots trajectorySurface3DPlot = new Mesh3DPlots();
	List<object> interpSectionsX = new List<object>();
	List<object> interpSectionsY = new List<object>();
	List<object> interpSectionsZ = new List<object>();
	List<object> interpSectionsX2 = new List<object>();
	List<object> interpSectionsY2 = new List<object>();
	List<object> interpSectionsZ2 = new List<object>();
	List<object> interpSectionsVSect = new List<object>();
	List<object> calcSectionsX = new List<object>();
	List<object> calcSectionsY = new List<object>();
	List<object> calcSectionsZ = new List<object>();
	List<object> calcSectionsX2 = new List<object>();
	List<object> calcSectionsY2 = new List<object>();
	List<object> calcSectionsZ2 = new List<object>();
	List<List<object>> calcSectionsXCompare = new List<List<object>>();
	List<List<object>> calcSectionsYCompare = new List<List<object>>();
	List<List<object>> calcSectionsZCompare = new List<List<object>>();
	List<List<object>> calcSectionsXList = new List<List<object>>();
	List<List<object>> calcSectionsYList = new List<List<object>>();
	List<List<object>> calcSectionsZList = new List<List<object>>();
	List<List<object>> calcSectionsXList2 = new List<List<object>>();
	List<List<object>> calcSectionsYList2 = new List<List<object>>();
	List<List<object>> calcSectionsZList2 = new List<List<object>>();
	List<List<List<object>>> calcSectionsXListCompare = new List<List<List<object>>>();
	List<List<List<object>>> calcSectionsYListCompare = new List<List<List<object>>>();
	List<List<List<object>>> calcSectionsZListCompare = new List<List<List<object>>>();
	List<string> valueListColorCompare = new List<string>();
	public List<bool> trajectoryCompareChBoxvalues { get; set; }

	protected override async Task OnInitializedAsync()
	{
		try
		{
			int[] initialTrajectoryIDs = null;
			//int[] initialTrajectoryIDs = await LoadTrajectoryIDs(NORCE.Drilling.Trajectory.WebApp.Client.Configuration.TrajectoryHostURL);
			if (initialTrajectoryIDs == null)
			{
				//initialTrajectoryIDs = await LoadTrajectoryIDs("http://host.docker.internal:" + NORCE.Drilling.Trajectory.WebApp.Client.Configuration.InternalTrajectoryHTTPPortNumber + "/");
			}
			if (initialTrajectoryIDs == null)
			{
				initialTrajectoryIDs = await LoadTrajectoryIDs("http://localhost:" + NORCE.Drilling.Trajectory.WebApp.Client.Configuration.InternalTrajectoryHTTPPortNumber + "/");
			}
			if (initialTrajectoryIDs == null)
			{
				initialTrajectoryIDs = await LoadTrajectoryIDs("https://localhost:44369/");
			}
			if (trajectoryCompareChBoxvalues == null && initialTrajectoryIDs != null)
			{
				trajectoryCompareChBoxvalues = new List<bool>();
				for (int i = 0; i < initialTrajectoryIDs.Length; i++)
				{
					trajectoryCompareChBoxvalues.Add(false);

				}
			}

			if (IsResultInputHidden == null)
			{
				IsResultInputHidden = new List<bool>();
			}
			if (IsResultDisplayHidden == null)
			{
				IsResultDisplayHidden = new List<bool>();
			}

			if (initialTrajectoryIDs != null)
			{
				trajectories = new List<NORCE.Drilling.Trajectory.ModelClientShared.Trajectory>();
				IsConfidenceLevelDisplayHidden = new List<bool>();
				IsConfidenceLevelInputHidden = new List<bool>();
				IsConfidenceLevelEditButtonHidden = new List<bool>();
				IsConfidenceLevelUpdateButtonHidden = new List<bool>();

				for (int i = 0; i < initialTrajectoryIDs.Length; i++)
				{
					var a = await httpTrajectory.GetAsync("Trajectories/" + initialTrajectoryIDs[i].ToString());
					if (a.IsSuccessStatusCode && a.Content != null)
					{
						string str = await a.Content.ReadAsStringAsync();
						if (!string.IsNullOrEmpty(str))
						{
							ModelClientShared.Trajectory trajectory = Newtonsoft.Json.JsonConvert.DeserializeObject<ModelClientShared.Trajectory>(str);
							if (trajectory != null)
							{
								trajectories.Add(trajectory);
								if (trajectory.SurveyList != null)

									IsConfidenceLevelDisplayHidden.Add(false);
								IsConfidenceLevelInputHidden.Add(true);
								IsConfidenceLevelEditButtonHidden.Add(false);
								IsConfidenceLevelUpdateButtonHidden.Add(true);

								if (!isInitialized)
								{
									confidenceLevels.Add(0.95);
								}
							}
						}
					}
				}
				isInitialized = true;
				if (listRadius.Count > 0)
				{
					PlotResults();
				}

			}

		}
		catch (Exception e)
		{
			System.Console.WriteLine(e.Message);
		}
	}

	private async Task<int[]> LoadTrajectoryIDs(string host)
	{
		int[] initialTrajectoryIDs = null;
		try
		{
			httpTrajectory = new HttpClient();
			httpTrajectory.BaseAddress = new Uri(host + "Trajectory/api/");
			httpTrajectory.DefaultRequestHeaders.Accept.Clear();
			httpTrajectory.DefaultRequestHeaders.Accept.Add(new System.Net.Http.Headers.MediaTypeWithQualityHeaderValue("application/json"));

			var a = await httpTrajectory.GetAsync("Trajectories");
			if (a.IsSuccessStatusCode)
			{
				string str = await a.Content.ReadAsStringAsync();
				if (!string.IsNullOrEmpty(str))
				{
					initialTrajectoryIDs = Newtonsoft.Json.JsonConvert.DeserializeObject<int[]>(str);
				}
			}
		}
		catch (Exception e)
		{
			httpTrajectory = null;
			initialTrajectoryIDs = null;
		}
		return initialTrajectoryIDs;
	}

	private void EditConfidenceLevel(int idx)
	{

		updatedConfidenceLevel = confidenceLevels[idx];
		for (int i = 0; i < IsConfidenceLevelDisplayHidden.Count; i++)
		{
			if (i == idx)
			{
				IsConfidenceLevelDisplayHidden[i] = true;
				IsConfidenceLevelInputHidden[i] = false;
				IsConfidenceLevelEditButtonHidden[i] = true;
				IsConfidenceLevelUpdateButtonHidden[i] = false;
			}
			else
			{
				IsConfidenceLevelDisplayHidden[i] = false;
			}
		}
	}

	private void UpdateConfidenceLevel(int idx)
	{

		confidenceLevels[idx] = updatedConfidenceLevel;
		for (int i = 0; i < IsConfidenceLevelDisplayHidden.Count; i++)
		{
			IsConfidenceLevelDisplayHidden[i] = false;
			IsConfidenceLevelInputHidden[i] = true;
			IsConfidenceLevelEditButtonHidden[i] = false;
			IsConfidenceLevelUpdateButtonHidden[i] = true;
		}
	}
	private async void Calculate(int idx)
	{
		currentIndex = idx;
		double confidenceLevel = confidenceLevels[idx];
		if (trajectories != null && idx >= 0 && idx < trajectories.Count && trajectories[idx].ID >= 0)
		{
			trajectoryName = trajectories[idx].Name;
			string s = "Trajectories/" + trajectories[idx].ID.ToString() + "/" + "0.95";
			var a = await httpTrajectory.GetAsync(s);
			Trajectory traj = new Trajectory();
			if (a.IsSuccessStatusCode)
			{
				string str = await a.Content.ReadAsStringAsync();
				if (!string.IsNullOrEmpty(str))
				{
					//traj = Newtonsoft.Json.JsonConvert.DeserializeObject<Trajectory>(str);
					List<List<double>> list = Newtonsoft.Json.JsonConvert.DeserializeObject<List<List<double>>>(str);
					listRadius = list;
					IsResultDisplayHidden.Clear();
					for (int i = 0; i < listRadius.Count; i++)
					{
						IsResultDisplayHidden.Add(false);
					}
				}
				IsTableResultHidden = false;
			}

			calcSectionsX.Clear();
			calcSectionsY.Clear();
			calcSectionsZ.Clear();

			calcSectionsXList.Clear();
			calcSectionsYList.Clear();
			calcSectionsZList.Clear();
			var b = await httpTrajectory.GetAsync("Trajectories/" + trajectories[idx].ID.ToString() + "/" + "0.95" + "/" + "1" + "/" + "10");
			if (b.IsSuccessStatusCode)
			{
				string str = await b.Content.ReadAsStringAsync();
				if (!string.IsNullOrEmpty(str))
				{
					var listOfEnvelopes = Newtonsoft.Json.JsonConvert.DeserializeObject<List<UncertaintyEnvelopeEllipse>>(str);
					for (int i = 0; i < listOfEnvelopes.Count; i++)
					{
						calcSectionsXList.Add(new List<object>());
						calcSectionsYList.Add(new List<object>());
						calcSectionsZList.Add(new List<object>());
						for (int j = 0; j < listOfEnvelopes[i].EllipseCoordinates.Count; j++)
						{
							calcSectionsX.Add(listOfEnvelopes[i].EllipseCoordinates.ElementAt(j).X);
							calcSectionsY.Add(listOfEnvelopes[i].EllipseCoordinates.ElementAt(j).Y);
							calcSectionsZ.Add(listOfEnvelopes[i].EllipseCoordinates.ElementAt(j).Z);
							calcSectionsXList[i].Add(listOfEnvelopes[i].EllipseCoordinates.ElementAt(j).X);
							calcSectionsYList[i].Add(listOfEnvelopes[i].EllipseCoordinates.ElementAt(j).Y);
							calcSectionsZList[i].Add(listOfEnvelopes[i].EllipseCoordinates.ElementAt(j).Z);
						}
					}
				}
			}
			calcSectionsXListCompare.Clear();
			calcSectionsYListCompare.Clear();
			calcSectionsZListCompare.Clear();
			calcSectionsXCompare.Clear();
			calcSectionsYCompare.Clear();
			calcSectionsZCompare.Clear();
			for (int i = 0; i < trajectoryCompareChBoxvalues.Count; i++)
			{
				bool ch = trajectoryCompareChBoxvalues[i];
				if (ch)
				{
					trajectoryName2 = trajectories[i].Name;
					string q = "Trajectories/" + trajectories[i].ID.ToString() + "/" + "0.95";
					var r = await httpTrajectory.GetAsync(q);
					if (r.IsSuccessStatusCode)
					{
						string str = await r.Content.ReadAsStringAsync();
						if (!string.IsNullOrEmpty(str))
						{
							List<List<double>> list = Newtonsoft.Json.JsonConvert.DeserializeObject<List<List<double>>>(str);
							listRadius2 = list;
						}
						IsTableResultHidden2 = false;
					}

					calcSectionsX2.Clear();
					calcSectionsY2.Clear();
					calcSectionsZ2.Clear();

					//valueListColorComapre = new List<string> { "green", "orange", "black" };
					valueListColorCompare = new List<string> { "salmon", "sandybrown",
				"seagreen", "seashell", "sienna", "silver", "skyblue",
				"slateblue", "slategray", "slategrey", "springgreen",
				"steelblue","tan", "teal","thistle", "tomato", "turquoise",
				"violet"};

					var c = await httpTrajectory.GetAsync("Trajectories/" + trajectories[i].ID.ToString() + "/" + "0.95" + "/" + "1" + "/" + "10");
					if (c.IsSuccessStatusCode)
					{
						string str = await c.Content.ReadAsStringAsync();
						if (!string.IsNullOrEmpty(str))
						{
							calcSectionsXListCompare.Add(new List<List<object>>());
							calcSectionsYListCompare.Add(new List<List<object>>());
							calcSectionsZListCompare.Add(new List<List<object>>());

							calcSectionsXCompare.Add(new List<object>());
							calcSectionsYCompare.Add(new List<object>());
							calcSectionsZCompare.Add(new List<object>());

							var listOfEnvelopes = Newtonsoft.Json.JsonConvert.DeserializeObject<List<UncertaintyEnvelopeEllipse>>(str);
							for (int j = 0; j < listOfEnvelopes.Count; j++)
							{
								calcSectionsXList2.Add(new List<object>());
								calcSectionsYList2.Add(new List<object>());
								calcSectionsZList2.Add(new List<object>());
								calcSectionsXListCompare[calcSectionsXListCompare.Count-1].Add(new List<object>());
								calcSectionsYListCompare[calcSectionsXListCompare.Count - 1].Add(new List<object>());
								calcSectionsZListCompare[calcSectionsXListCompare.Count - 1].Add(new List<object>());
								for (int k = 0; k < listOfEnvelopes[j].EllipseCoordinates.Count; k++)
								{
									calcSectionsX2.Add(listOfEnvelopes[j].EllipseCoordinates.ElementAt(k).X);
									calcSectionsY2.Add(listOfEnvelopes[j].EllipseCoordinates.ElementAt(k).Y);
									calcSectionsZ2.Add(listOfEnvelopes[j].EllipseCoordinates.ElementAt(k).Z);
									calcSectionsXCompare[calcSectionsXListCompare.Count - 1].Add(listOfEnvelopes[j].EllipseCoordinates.ElementAt(k).X);
									calcSectionsYCompare[calcSectionsXListCompare.Count - 1].Add(listOfEnvelopes[j].EllipseCoordinates.ElementAt(k).Y);
									calcSectionsZCompare[calcSectionsXListCompare.Count - 1].Add(listOfEnvelopes[j].EllipseCoordinates.ElementAt(k).Z);
									//calcSectionsXList2[j].Add(listOfEnvelopes[j].EllipseCoordinates.ElementAt(k).X);
									//calcSectionsYList2[j].Add(listOfEnvelopes[j].EllipseCoordinates.ElementAt(k).Y);
									//calcSectionsZList2[j].Add(listOfEnvelopes[j].EllipseCoordinates.ElementAt(k).Z);
									calcSectionsXListCompare[calcSectionsXListCompare.Count - 1][j].Add(listOfEnvelopes[j].EllipseCoordinates.ElementAt(k).X);
									calcSectionsYListCompare[calcSectionsXListCompare.Count - 1][j].Add(listOfEnvelopes[j].EllipseCoordinates.ElementAt(k).Y);
									calcSectionsZListCompare[calcSectionsXListCompare.Count - 1][j].Add(listOfEnvelopes[j].EllipseCoordinates.ElementAt(k).Z);
								}
							}
						}

					}
				}
			}

			if (a.IsSuccessStatusCode)
			{
				await OnInitializedAsync();
				await InvokeAsync(() => { StateHasChanged(); });
			}
		}
	}

	private async void PlotResults()
	{
		interpSectionsX.Clear();
		interpSectionsY.Clear();
		interpSectionsZ.Clear();
		interpSectionsVSect.Clear();
		interpSectionsX2.Clear();
		interpSectionsY2.Clear();
		interpSectionsZ2.Clear();

		CurvilinearPoint3D prevPoint = null;
		for (int i = 0; i < trajectories[currentIndex].SurveyList.Count; ++i)
		{
			CurvilinearPoint3D point = null;
			point = trajectories[currentIndex].SurveyList.ListOfSurveys.ElementAt(i);
			double x = (double)trajectories[currentIndex].SurveyList.ListOfSurveys.ElementAt(i).NorthOfWellHead;
			double y = (double)trajectories[currentIndex].SurveyList.ListOfSurveys.ElementAt(i).EastOfWellHead;
			double z = (double)trajectories[currentIndex].SurveyList.ListOfSurveys.ElementAt(i).Z;
			interpSectionsX.Add(point.X);
			interpSectionsY.Add(point.Y);
			interpSectionsZ.Add(point.Z);
			prevPoint = point;

		}

		for (int id = 0; id < trajectoryCompareChBoxvalues.Count; id++)
		{
			bool ch = trajectoryCompareChBoxvalues[id];
			if (ch)
			{
				for (int i = 0; i < trajectories[id].SurveyList.Count; ++i)
				{
					CurvilinearPoint3D point = null;
					point = trajectories[id].SurveyList.ListOfSurveys.ElementAt(i);
					double x = (double)trajectories[id].SurveyList.ListOfSurveys.ElementAt(i).NorthOfWellHead;
					double y = (double)trajectories[id].SurveyList.ListOfSurveys.ElementAt(i).EastOfWellHead;
					double z = (double)trajectories[id].SurveyList.ListOfSurveys.ElementAt(i).Z;
					interpSectionsX2.Add(point.X);
					interpSectionsY2.Add(point.Y);
					interpSectionsZ2.Add(point.Z);
					prevPoint = point;

				}
			}
		}
		await trajectorySurface3DPlot.Plot();
	}

}