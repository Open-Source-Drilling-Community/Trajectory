@page "/SurveyStationUncertainty"
@using System.Text;
@using NORCE.Drilling.Trajectory.WebApp.Client
@using NORCE.Drilling.Trajectory.ModelClientShared;
<h3>SurveyStationUncertainty</h3>



@if (trajectories == null)
{
	<p><em>Loading...</em></p>
}
else
{
	<h2>Trajectory List</h2>
	<table class="table">
		<thead>
			<tr>
				<th>Name</th>
				<th>Description</th>
				<th></th>
			</tr>
		</thead>
		<tbody>
			@for (int i = 0; i < trajectories.Count; i++)
			{
				var local = i;
				<tr>
					<td>
						<span class="label" hidden="@IsTrajectoryDisplayHidden[i]">@trajectories[i].Name</span>
						@*<input class="text" type="text" hidden="@IsTrajectoryInputHidden[i]" @bind="@updatedTrajectory.Name" />*@
					</td>
					<td>
						<span class="label" hidden="@IsTrajectoryDisplayHidden[i]">@trajectories[i].Description</span>
						@*<input class="text" type="text" hidden="@IsTrajectoryInputHidden[i]" @bind="@updatedTrajectory.Description" />*@
					</td>

					<td>
						<button class="btn btn-primary" hidden="@IsTrajectoryCalculateButtonHidden[i]" @onclick="@(() => Calculate(local))">Calculate</button>

					</td>
				</tr>
			}
		</tbody>
		<!--<tfoot>
			<tr>
				<td>
					<input class="text" type="text" hidden="@IsTrajectoryAddInput" @bind="@editedTrajectory.Name" />
				</td>
				<td>
					<input class="text" type="text" hidden="@IsTrajectoryAddInput" @bind="@editedTrajectory.Description" />
				</td>
				<td>-->
		@*<button class="btn btn-primary" hidden="@IsTrajectoryAddInput" @onclick="Add">Add</button>
			<button class="btn btn-primary" hidden="@IsTrajectoryAddInput" @onclick="Cancel">Cancel</button>*@
		<!--</td>
			</tr>
		</tfoot>-->
	</table>
	<div>
		<table class="table" hidden="@IsTableResultHidden">
			<thead></thead>
			<tbody>
				<tr>
					<td>
						@if (trajectories != null)
						{
							<Scatter3DPlot XValues="@interpSectionsX"
										   YValues="@interpSectionsY"
										   ZValues="@interpSectionsZ"
										   ValuesName="Interpolated"
										   XMarkerValues="@calcSectionsX"
										   YMarkerValues="@calcSectionsY"
										   ZMarkerValues="@calcSectionsZ"
										   MarkerValuesName="Calculated"
										   PlotHeight="800"
										   PlotWidth="800"
										   PlotTitle="t"
										   XAxisTitle="North (m)"
										   YAxisTitle="East (m)"
										   ZAxisTitle="TVD (m)"
										   ZAxisIsReversed="@false"
										   @ref="@trajectory3DPlot"></Scatter3DPlot>
						}
					</td>
					<td>
					</td>
				</tr>
			</tbody>
			<tfoot></tfoot>
		</table>
		
	</div>
	<h2 hidden="@IsTableResultHidden">Ellipse Radiuses @trajectoryName</h2>

	<table class="table" hidden="@IsTableResultHidden">
		<thead>
			<tr>
				<th>R1</th>
				<th>R2</th>
				<th></th>
			</tr>
		</thead>
		<tbody>
			@for (int i = 0; i < listRadius.Count; i++)
			{
				List<double> list = listRadius[i];
				if (list[0] != null)
				{

					<tr>
						<td>
							<span class="label" hidden="@IsResultDisplayHidden[i]">@list[0]</span>
							@*<input class="text" type="text" hidden="@IsResultInputHidden[i]" @bind="@list[0]" />*@
						</td>
						<td>
							<span class="label" hidden="@IsResultDisplayHidden[i]">@list[1]</span>
							@*<input class="text" type="text" hidden="@IsResultInputHidden[i]" @bind="@list[1]" />*@
						</td>

					</tr>
				}
			}
		</tbody>
	</table>

}

@code {
	private HttpClient httpTrajectory;
	private List<bool> IsTrajectoryDisplayHidden;
	private List<bool> IsTrajectoryInputHidden;
	private List<bool> IsResultDisplayHidden;
	private List<bool> IsResultInputHidden;
	private bool IsTableResultHidden;
	private List<bool> IsTrajectoryCalculateButtonHidden;
	private List<NORCE.Drilling.Trajectory.ModelClientShared.Trajectory> trajectories;
	private List<NORCE.Drilling.Trajectory.ModelClientShared.SurveyStation> surveyStations;
	private List<List<double>> listRadius = new List<List<double>>();
	private int currentIndex = 0;


	private string trajectoryName;


	private NORCE.Drilling.Trajectory.ModelClientShared.Trajectory editedTrajectory;

	Scatter3DPlot trajectory3DPlot = new Scatter3DPlot();
	List<object> interpSectionsX = new List<object>();
	List<object> interpSectionsY = new List<object>();
	List<object> interpSectionsZ = new List<object>();
	List<object> interpSectionsVSect = new List<object>();
	List<object> calcSectionsX = new List<object>();
	List<object> calcSectionsY = new List<object>();
	List<object> calcSectionsZ = new List<object>();

	protected override async Task OnInitializedAsync()
	{
		try
		{

			if (editedTrajectory == null)
			{
				editedTrajectory = new NORCE.Drilling.Trajectory.ModelClientShared.Trajectory();
				editedTrajectory.ID = -1;
			}

			int[] initialTrajectoryIDs = await LoadTrajectoryIDs(NORCE.Drilling.Trajectory.WebApp.Client.Configuration.TrajectoryHostURL);
			if (initialTrajectoryIDs == null)
			{
				//initialTrajectoryIDs = await LoadTrajectoryIDs("http://host.docker.internal:" + NORCE.Drilling.Trajectory.WebApp.Client.Configuration.InternalTrajectoryHTTPPortNumber + "/");
			}
			if (initialTrajectoryIDs == null)
			{
				initialTrajectoryIDs = await LoadTrajectoryIDs("http://localhost:" + NORCE.Drilling.Trajectory.WebApp.Client.Configuration.InternalTrajectoryHTTPPortNumber + "/");
			}
			if (initialTrajectoryIDs == null)
			{
				initialTrajectoryIDs = await LoadTrajectoryIDs("https://localhost:44369/");
			}


			if (IsResultInputHidden == null)
			{
				IsResultInputHidden = new List<bool>();
			}
			if (IsResultDisplayHidden == null)
			{
				IsResultDisplayHidden = new List<bool>();
			}

			if (initialTrajectoryIDs != null)
			{
				trajectories = new List<NORCE.Drilling.Trajectory.ModelClientShared.Trajectory>();
				IsTrajectoryDisplayHidden = new List<bool>();
				IsTrajectoryInputHidden = new List<bool>();
				IsTrajectoryCalculateButtonHidden = new List<bool>();


				for (int i = 0; i < initialTrajectoryIDs.Length; i++)
				{
					var a = await httpTrajectory.GetAsync("Trajectories/" + initialTrajectoryIDs[i].ToString());
					if (a.IsSuccessStatusCode && a.Content != null)
					{
						string str = await a.Content.ReadAsStringAsync();
						if (!string.IsNullOrEmpty(str))
						{
							ModelClientShared.Trajectory trajectory = Newtonsoft.Json.JsonConvert.DeserializeObject<ModelClientShared.Trajectory>(str);
							if (trajectory != null)
							{
								trajectories.Add(trajectory);
								if (trajectory.SurveyList != null)

									IsTrajectoryDisplayHidden.Add(false);
								IsTrajectoryInputHidden.Add(true);
								IsTrajectoryCalculateButtonHidden.Add(false);

							}
						}
					}
				}
				if (listRadius.Count > 0)
				{
					PlotResults();
				}

			}

		}
		catch (Exception e)
		{
			System.Console.WriteLine(e.Message);
		}
	}

	private async Task<int[]> LoadTrajectoryIDs(string host)
	{
		int[] initialTrajectoryIDs = null;
		try
		{
			httpTrajectory = new HttpClient();
			httpTrajectory.BaseAddress = new Uri(host + "Trajectory/api/");
			httpTrajectory.DefaultRequestHeaders.Accept.Clear();
			httpTrajectory.DefaultRequestHeaders.Accept.Add(new System.Net.Http.Headers.MediaTypeWithQualityHeaderValue("application/json"));

			var a = await httpTrajectory.GetAsync("Trajectories");
			if (a.IsSuccessStatusCode)
			{
				string str = await a.Content.ReadAsStringAsync();
				if (!string.IsNullOrEmpty(str))
				{
					initialTrajectoryIDs = Newtonsoft.Json.JsonConvert.DeserializeObject<int[]>(str);
				}
			}
		}
		catch (Exception e)
		{
			httpTrajectory = null;
			initialTrajectoryIDs = null;
		}
		return initialTrajectoryIDs;
	}

	private async void Calculate(int idx)
	{
		currentIndex = idx;
		if (trajectories != null && idx >= 0 && idx < trajectories.Count && trajectories[idx].ID >= 0)
		{

			string req = "Trajectories/" + trajectories[idx].ID.ToString();
			string s = "Trajectories/" + trajectories[idx].ID.ToString() + "/" + "0.95";
			//var b = await httpTrajectory.GetAsync("Trajectories/" + trajectories[idx].ID.ToString() + "/" + "1" + "/" + "1");
			var a = await httpTrajectory.GetAsync(s);
			Trajectory traj = new Trajectory();
			if (a.IsSuccessStatusCode)
			{
				string str = await a.Content.ReadAsStringAsync();
				if (!string.IsNullOrEmpty(str))
				{
					//traj = Newtonsoft.Json.JsonConvert.DeserializeObject<Trajectory>(str);
					List<List<double>> list = Newtonsoft.Json.JsonConvert.DeserializeObject<List<List<double>>>(str);
					listRadius = list;
					IsResultDisplayHidden.Clear();
					for (int i = 0; i < listRadius.Count; i++)
					{
						IsResultDisplayHidden.Add(false);
					}
				}
				IsTableResultHidden = false;
			}

			calcSectionsX.Clear();
			calcSectionsY.Clear();
			calcSectionsZ.Clear();
			var b = await httpTrajectory.GetAsync("Trajectories/" + trajectories[idx].ID.ToString() + "/" + "0.95" + "/" + "1");
			if (b.IsSuccessStatusCode)
			{
				string str = await b.Content.ReadAsStringAsync();
				if (!string.IsNullOrEmpty(str))
				{
					//traj = Newtonsoft.Json.JsonConvert.DeserializeObject<Trajectory>(str);
					var listOfEnvelopes = Newtonsoft.Json.JsonConvert.DeserializeObject<List<UncertaintyEnvelopeEllipse>>(str);
					for(int i=0;i< listOfEnvelopes.Count;i++)
					{
						for (int j = 0; j < listOfEnvelopes[i].EllipseCoordinates.Count; j++)
						{
							//Generate the calculated marker curve
							//CurvilinearPoint3D point = null;
							//point = listOfEnvelopes[i].EllipseCoordinates.ElementAt(j).X;
							calcSectionsX.Add(listOfEnvelopes[i].EllipseCoordinates.ElementAt(j).X);
							calcSectionsY.Add(listOfEnvelopes[i].EllipseCoordinates.ElementAt(j).Y);
							calcSectionsZ.Add(listOfEnvelopes[i].EllipseCoordinates.ElementAt(j).Z);
						}
					}
				}
			}
			////Generate the calculated marker curve

			//for (int i = 0; i < trajectories[currentIndex].SurveyList.Count; ++i)
			//{
			//	int sectionIdx = System.Math.Max(0, i - 1);
			//	CurvilinearPoint3D point = null;
			//	point = trajectories[currentIndex].SurveyList.ListOfSurveys.ElementAt(i);
			//	calcSectionsX.Add(point.X);
			//	calcSectionsY.Add(point.Y);
			//	calcSectionsZ.Add(point.Z);

			//}

			for (int i = 0; i < IsTrajectoryDisplayHidden.Count; i++)
			{
				IsTrajectoryDisplayHidden[i] = false;
				IsTrajectoryInputHidden[i] = true;
			}
			if (a.IsSuccessStatusCode)
			{
				await OnInitializedAsync();
				await InvokeAsync(() => { StateHasChanged(); });
			}
		}
	}

	private async void PlotResults()
	{
		// update scatter plot
		interpSectionsX.Clear();
		interpSectionsY.Clear();
		interpSectionsZ.Clear();
		interpSectionsVSect.Clear();
		//calcSectionsX.Clear();
		//calcSectionsY.Clear();
		//calcSectionsZ.Clear();

		//Generate the interpolated curve
		CurvilinearPoint3D prevPoint = null;
		double vSect = 0.0;
		for (int i = 0; i < trajectories[currentIndex].SurveyList.Count; ++i)
		{
			CurvilinearPoint3D point = null;
			point = trajectories[currentIndex].SurveyList.ListOfSurveys.ElementAt(i);
			double x = (double)trajectories[currentIndex].SurveyList.ListOfSurveys.ElementAt(i).X;
			double y = (double)trajectories[currentIndex].SurveyList.ListOfSurveys.ElementAt(i).Y;
			double z = (double)trajectories[currentIndex].SurveyList.ListOfSurveys.ElementAt(i).Z;



			interpSectionsX.Add(point.X);
			interpSectionsY.Add(point.Y);
			interpSectionsZ.Add(point.Z);
			//vSect += System.Math.Sqrt(System.Math.Pow((double)(point.X - prevPoint.X), 2.0) + System.Math.Pow((double)(point.Y - prevPoint.Y), 2.0));
			//interpSectionsVSect.Add(vSect);
			prevPoint = point;

		}


		////Generate the calculated marker curve
		//prevPoint = null;
		//vSect = 0.0;
		//for (int i = 0; i < trajectories[currentIndex].SurveyList.Count; ++i)
		//{
		//	int sectionIdx = System.Math.Max(0, i - 1);


		//	CurvilinearPoint3D point = null;
		//	point = trajectories[currentIndex].SurveyList.ListOfSurveys.ElementAt(i);
		//	calcSectionsX.Add(point.X);
		//	calcSectionsY.Add(point.Y);
		//	calcSectionsZ.Add(point.Z);
		//	//vSect += System.Math.Sqrt(System.Math.Pow((double)(point.X - prevPoint.X), 2.0) + System.Math.Pow((double)(point.Y - prevPoint.Y), 2.0));
		//	prevPoint = point;

		//}
		//trajectory3DPlot.PlotTitle = "t";
		//trajectory3DPlot.XMarkerValues = calcSectionsX;
		//trajectory3DPlot.YMarkerValues = calcSectionsY;
		//trajectory3DPlot.ZMarkerValues = calcSectionsZ;
		//trajectory3DPlot.MarkerValuesName = "X";
		await trajectory3DPlot.Plot();
	}
}